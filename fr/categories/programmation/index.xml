<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Programmation on Simon Désaulniers</title>
    <link>https://sim590.github.io/fr/categories/programmation/</link>
    <description>Recent content in Programmation on Simon Désaulniers</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <managingEditor>sim.desaulniers@gmail.com (Simon Désaulniers)</managingEditor>
    <webMaster>sim.desaulniers@gmail.com (Simon Désaulniers)</webMaster>
    <copyright>©2020 Simon Désaulniers, All Rights Reserved</copyright>
    <lastBuildDate>Fri, 23 Jul 2021 04:03:00 -0400</lastBuildDate>
    
        <atom:link href="https://sim590.github.io/fr/categories/programmation/index.xml" rel="self" type="application/rss+xml" />
    

      
      <item>
        <title>Transformateurs: composition de monades</title>
        <link>https://sim590.github.io/fr/haskell/transformateurs/</link>
        <pubDate>Fri, 23 Jul 2021 04:03:00 -0400</pubDate>
        <author>sim.desaulniers@gmail.com (Simon Désaulniers)</author>
        <atom:modified>Fri, 23 Jul 2021 04:03:00 -0400</atom:modified>
        <guid>https://sim590.github.io/fr/haskell/transformateurs/</guid>
        <description>&lt;script type=&#34;text/javascript&#34;
  src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#34;&gt;
&lt;/script&gt;
&lt;p&gt;Dès lors qu&amp;rsquo;on découvre les monades et leur utilité, on ne peut faire autrement
que de les étudier davantage et trouver les occasions pour les utiliser. Après
tout, ils sont des concepts clefs dans l&amp;rsquo;utilisation sérieuse d&amp;rsquo;un langage
fonctionnel comme Haskell. Par exemple, on ne peut pas faire d&amp;rsquo;opérations
d&amp;rsquo;entrée/sortie si on ne fonctionne pas dans la monade &lt;code&gt;IO&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Une limitation importante prend forme très rapidement sous nos yeux: il devient
difficile d&amp;rsquo;utiliser plusieurs monades ensembles car on doit forcément les
développer pour passer d&amp;rsquo;une monade à l&amp;rsquo;autre. Ce faisant, on doit choisir entre
les propriétés d&amp;rsquo;une monade ou l&amp;rsquo;autre et on ne peut donc pas bénéficier des
différents monades en même temps. Les transformateurs de monades visent
justement à régler ce problème de manière à fournir une écriture finale
satisfaisante autant au niveau sémantique que pour l&amp;rsquo;organisation logique du
code.&lt;/p&gt;</description>
        
        <dc:creator>Simon Désaulniers</dc:creator>
        
        
        <media:content url="https://sim590.github.io/images/haskell.png" medium="image"><media:title type="html">meta image</media:title></media:content>
        
          
            
              <category>Transformateur</category>
            
          
            
              <category>Monade</category>
            
          
            
              <category>Composition</category>
            
          
        
        
          
            
              <category>Haskell</category>
            
          
            
              <category>Programmation</category>
            
          
        
        
      </item>
      
      <item>
        <title>La monade Maybe</title>
        <link>https://sim590.github.io/fr/haskell/monademaybe/</link>
        <pubDate>Fri, 16 Oct 2020 01:17:31 -0400</pubDate>
        <author>sim.desaulniers@gmail.com (Simon Désaulniers)</author>
        <atom:modified>Fri, 16 Oct 2020 01:17:31 -0400</atom:modified>
        <guid>https://sim590.github.io/fr/haskell/monademaybe/</guid>
        <description>&lt;p&gt;Dans cet article, je souhaite introduire le programmeur à la monade &lt;code&gt;Maybe&lt;/code&gt;. Je
compte le faire en utilisant le langage Haskell puisqu&amp;rsquo;il s&amp;rsquo;agit du langage
fonctionnel que je maîtrise le mieux et que je le considère très expressif et
accessible. Afin de démontrer les bénéfices de la monade et des concepts
d&amp;rsquo;Haskell, je vais comparer ceux-ci aux méthodes usuelles du langage C++.&lt;/p&gt;
&lt;p&gt;En une phrase, la monade &lt;code&gt;Maybe&lt;/code&gt; peut être vue comme un &lt;em&gt;design pattern&lt;/em&gt; de
gestion des cas d&amp;rsquo;erreur ou d&amp;rsquo;exception. Je vais donc utiliser un exemple fictif
et peu réaliste, mais simple, qui permet de capturer l&amp;rsquo;idée générale. Disons
qu&amp;rsquo;on a une liste de contacts pour lesquels on souhaite exécuter un traitement.
Cependant, on décide que, dans la région du programme où on implémente le code
associé à cette liste de contact, une opération qui échoue sur un contact
devrait arrêter le fil d&amp;rsquo;exécution du programme.&lt;/p&gt;</description>
        
        <dc:creator>Simon Désaulniers</dc:creator>
        
        
        <media:content url="https://sim590.github.io/images/haskell.png" medium="image"><media:title type="html">meta image</media:title></media:content>
        
          
            
              <category>Maybe</category>
            
          
            
              <category>Monad</category>
            
          
            
              <category>Gestion d&#39;erreurs</category>
            
          
            
              <category>Générécité</category>
            
          
        
        
          
            
              <category>Haskell</category>
            
          
            
              <category>Programmation</category>
            
          
            
              <category>Monade</category>
            
          
        
        
      </item>
      
      <item>
        <title>Vim peut tout faire</title>
        <link>https://sim590.github.io/fr/vim/vim-peut-tout-faire/</link>
        <pubDate>Sun, 22 Mar 2020 11:11:56 -0400</pubDate>
        <author>sim.desaulniers@gmail.com (Simon Désaulniers)</author>
        <atom:modified>Sun, 22 Mar 2020 11:11:56 -0400</atom:modified>
        <guid>https://sim590.github.io/fr/vim/vim-peut-tout-faire/</guid>
        <description>&lt;p&gt;Vim est un &lt;a href=&#34;https://fr.wikipedia.org/wiki/%C3%89diteur_de_texte&#34;&gt;éditeur de texte&lt;/a&gt; et clairement le meilleur qui soit. Je ne
dis pas ça sans peser mes mots. Ceci dit, il ne faut pas lui prêter une identité
qu&amp;rsquo;il n&amp;rsquo;a pas. Vim n&amp;rsquo;est pas un environnement de développement intégré (EDI ou
IDE en anglais) complet.  Cependant, plusieurs aspects à son utilisation font sa
grande force pour fournir un EDI complet à son usager:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;un &lt;strong&gt;langage de touches&lt;/strong&gt; permettant aux doigts de faire tout le travail
d&amp;rsquo;édition de texte (couper, effacer, coller, réordonner, formater, etc.). En
effet, dans une boîte de texte régulière (comme ce qu&amp;rsquo;on trouve dans les EDIs
populaires) la modification de texte, et non la simple écriture, n&amp;rsquo;est pas
chose facile. Elle demande souvent l&amp;rsquo;utilisation de la souris, donc la perte
de la position des mains déjà en place pour écrire. De plus, cette approche
est normalement très lente. Avec Vim, les doigts font le travail. La meilleure
comparaison pour comprendre le sentiment est justement celle de l&amp;rsquo;écriture. On
ne pense pas à trouver les touches pour écrire et cela se fait
automatiquement. Pour la modification de texte avec Vim, c&amp;rsquo;est la même chose.&lt;/li&gt;
&lt;li&gt;un &lt;strong&gt;langage de script&lt;/strong&gt; (&lt;em&gt;VimScript&lt;/em&gt;) qui lui permet une haute extensibilité;&lt;/li&gt;
&lt;li&gt;une &lt;strong&gt;intégration de l&amp;rsquo;interface système&lt;/strong&gt; (IS ou le &lt;em&gt;shell&lt;/em&gt; en anglais).
L&amp;rsquo;utilisation de l&amp;rsquo;IS est entièrement intégrée à travers VimScript ainsi que
les différents modes de Vim (Normal, Visual, CMD, etc.). Je ne peux mettre
assez l&amp;rsquo;accent sur comment ce trait de Vim est &lt;strong&gt;si significatif&lt;/strong&gt;. Ce
faisant, de manière totalement gratuite, un utilisateur de Vim bénéficie déjà
des fonctionnalités de l&amp;rsquo;IS dans son éditeur de texte sans avoir recours à
l&amp;rsquo;installation très particulière d&amp;rsquo;extension par son EDI. On dit souvent que
l&amp;rsquo;IS constitue en réalité l&amp;rsquo;environnement de développement d&amp;rsquo;un utilisateur de
Vim.&lt;/li&gt;
&lt;li&gt;une capacité d&amp;rsquo;intégrer des &lt;strong&gt;greffons&lt;/strong&gt; (&lt;em&gt;plugins&lt;/em&gt; en anglais);&lt;/li&gt;
&lt;li&gt;et une &lt;strong&gt;communauté de développeurs&lt;/strong&gt; très investie dans le partage de code et
d&amp;rsquo;outils qui rendent l&amp;rsquo;intégration d&amp;rsquo;outils de développement aisée et
facilement personnalisable.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Le tout fait de Vim le choix idéal. Dans ce qui suit, je prends le temps de
développer concrètement mon point de vue en m&amp;rsquo;attardant à des préoccupations
très importantes de tout développeur, mais selon ma perspective, bien entendu.
Je compte donc explorer le mode Normal de Vim, l&amp;rsquo;intégration avec l&amp;rsquo;IS plus en
détail, l&amp;rsquo;intégration de &lt;a href=&#34;https://fr.wikipedia.org/wiki/GNU_Debugger&#34;&gt;GDB&lt;/a&gt; (depuis Vim 8) et les différents greffons
permettant une sensation d&amp;rsquo;EDI complet.&lt;/p&gt;</description>
        
        <dc:creator>Simon Désaulniers</dc:creator>
        
        
        <media:content url="https://sim590.github.io/images/vim/vim-peut-tout-faire/vim-all-the-things.png" medium="image"><media:title type="html">meta image</media:title></media:content>
        
          
            
              <category>Vim</category>
            
          
            
              <category>hjkl</category>
            
          
            
              <category>greffon</category>
            
          
        
        
          
            
              <category>Techno</category>
            
          
            
              <category>Outil</category>
            
          
            
              <category>Éditeur de texte</category>
            
          
            
              <category>Programmation</category>
            
          
        
        
      </item>
      
      <item>
        <title>Haskell: programmation dynamique</title>
        <link>https://sim590.github.io/fr/haskell/programmation-dynamique/</link>
        <pubDate>Mon, 02 Mar 2020 04:06:13 -0500</pubDate>
        <author>sim.desaulniers@gmail.com (Simon Désaulniers)</author>
        <atom:modified>Mon, 02 Mar 2020 04:06:13 -0500</atom:modified>
        <guid>https://sim590.github.io/fr/haskell/programmation-dynamique/</guid>
        <description>&lt;script type=&#34;text/javascript&#34;
  src=&#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#34;&gt;
&lt;/script&gt;
&lt;p&gt;L&amp;rsquo;approche de programmation dynamique est souvent associée au remplissage d&amp;rsquo;un
tableau à deux dimensions et à l&amp;rsquo;écriture explicite de ce procédé sous forme
itérative. Dans un langage fonctionnel comme Haskell, on bénéficie de quelques
avantages d&amp;rsquo;expressivité de haut niveau et de lisibilité qu&amp;rsquo;on ne retrouve pas
autrement.&lt;/p&gt;
&lt;p&gt;Dans cet article, je commence par explorer deux exemples triviaux de
programmation dynamique. Ensuite, je passe sur un problème tout aussi
accessible, mais dont l&amp;rsquo;achèvement optimal demandera l&amp;rsquo;utilisation d&amp;rsquo;une
structure &lt;code&gt;Data.Array&lt;/code&gt; plutôt que la liste conventionnelle.&lt;/p&gt;</description>
        
        <dc:creator>Simon Désaulniers</dc:creator>
        
        
        <media:content url="https://sim590.github.io/images/haskell.png" medium="image"><media:title type="html">meta image</media:title></media:content>
        
          
            
              <category>Séquence de Collatz</category>
            
          
            
              <category>Data.Array</category>
            
          
            
              <category>nombre triangulaire</category>
            
          
        
        
          
            
              <category>Algorithmique</category>
            
          
            
              <category>Haskell</category>
            
          
            
              <category>Mémoïsation</category>
            
          
            
              <category>Programmation</category>
            
          
            
              <category>Programmation dynamique</category>
            
          
        
        
      </item>
      

    
  </channel>
</rss>
