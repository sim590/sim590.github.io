<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" 
  xmlns:content="http://purl.org/rss/1.0/modules/content/" 
  xmlns:dc="http://purl.org/dc/elements/1.1/" 
  xmlns:atom="http://www.w3.org/2005/Atom" 
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" 
  xmlns:media="http://search.yahoo.com/mrss/">
  <channel>
    <title>Haskell on Simon Désaulniers</title>
    <link>https://sim590.github.io/fr/haskell/</link>
    <description>Recent content in Haskell on Simon Désaulniers</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr</language>
    <managingEditor>sim.desaulniers@gmail.com (Simon Désaulniers)</managingEditor>
    <webMaster>sim.desaulniers@gmail.com (Simon Désaulniers)</webMaster>
    <copyright>©2020 Simon Désaulniers, All Rights Reserved</copyright>
    <lastBuildDate>Fri, 23 Jul 2021 04:03:00 -0400</lastBuildDate>
    
        <atom:link href="https://sim590.github.io/fr/haskell/index.xml" rel="self" type="application/rss+xml" />
    
    
    

      
      <item>
        <title>Transformateurs: composition de monades</title>
        <link>https://sim590.github.io/fr/haskell/transformateurs/</link>
        <pubDate>Fri, 23 Jul 2021 04:03:00 -0400</pubDate>
        <author>sim.desaulniers@gmail.com (Simon Désaulniers)</author>
        <atom:modified>Fri, 23 Jul 2021 04:03:00 -0400</atom:modified>
        <guid>https://sim590.github.io/fr/haskell/transformateurs/</guid>
        <description>Dès lors qu&amp;rsquo;on découvre les monades et leur utilité, on ne peut faire autrement que de les étudier davantage et trouver les occasions pour les utiliser. Après tout, ils sont des concepts clefs dans l&amp;rsquo;utilisation sérieuse d&amp;rsquo;un langage fonctionnel comme Haskell. Par exemple, on ne peut pas faire d&amp;rsquo;opérations d&amp;rsquo;entrée/sortie si on ne fonctionne pas dans la monade IO.
Une limitation importante prend forme très rapidement sous nos yeux: il est devient difficile d&amp;rsquo;utiliser plusieurs monades ensembles car on doit forcément les développer pour passer d&amp;rsquo;une monade à l&amp;rsquo;autre.</description>
        
        <dc:creator>Simon Désaulniers</dc:creator>
        
        
        <media:content url="https://sim590.github.ioimages/haskell.png" medium="image"><media:title type="html">meta image</media:title></media:content>
        
          
            
              <category>Transformateur</category>
            
          
            
              <category>Monade</category>
            
          
            
              <category>Composition</category>
            
          
        
        
          
            
              <category>Haskell</category>
            
          
            
              <category>Programmation</category>
            
          
        
        
      </item>
      
      <item>
        <title>La monade Maybe</title>
        <link>https://sim590.github.io/fr/haskell/monademaybe/</link>
        <pubDate>Fri, 16 Oct 2020 01:17:31 -0400</pubDate>
        <author>sim.desaulniers@gmail.com (Simon Désaulniers)</author>
        <atom:modified>Fri, 16 Oct 2020 01:17:31 -0400</atom:modified>
        <guid>https://sim590.github.io/fr/haskell/monademaybe/</guid>
        <description>Dans cet article, je souhaite introduire le programmeur à la monade Maybe. Je compte le faire en utilisant le langage Haskell puisqu&amp;rsquo;il s&amp;rsquo;agit du langage fonctionnel que je maîtrise le mieux et que je le considère très expressif et accessible. Afin de démontrer les bénéfices de la monade et des concepts d&amp;rsquo;Haskell, je vais comparer ceux-ci aux méthodes usuelles du langage C++.
En une phrase, la monade Maybe peut être vue comme un design pattern de gestion des cas d&amp;rsquo;erreur ou d&amp;rsquo;exception.</description>
        
        <dc:creator>Simon Désaulniers</dc:creator>
        
        
        <media:content url="https://sim590.github.ioimages/haskell.png" medium="image"><media:title type="html">meta image</media:title></media:content>
        
          
            
              <category>Maybe</category>
            
          
            
              <category>Monad</category>
            
          
            
              <category>Gestion d&#39;erreurs</category>
            
          
            
              <category>Générécité</category>
            
          
        
        
          
            
              <category>Haskell</category>
            
          
            
              <category>Programmation</category>
            
          
            
              <category>Monade</category>
            
          
        
        
      </item>
      
      <item>
        <title>Haskell: programmation dynamique</title>
        <link>https://sim590.github.io/fr/haskell/programmation-dynamique/</link>
        <pubDate>Mon, 02 Mar 2020 04:06:13 -0500</pubDate>
        <author>sim.desaulniers@gmail.com (Simon Désaulniers)</author>
        <atom:modified>Mon, 02 Mar 2020 04:06:13 -0500</atom:modified>
        <guid>https://sim590.github.io/fr/haskell/programmation-dynamique/</guid>
        <description>L&amp;rsquo;approche de programmation dynamique est souvent associée au remplissage d&amp;rsquo;un tableau à deux dimensions et à l&amp;rsquo;écriture explicite de ce procédé sous forme itérative. Dans un langage fonctionnel comme Haskell, on bénéficie de quelques avantages d&amp;rsquo;expressivité de haut niveau et de lisibilité qu&amp;rsquo;on ne retrouve pas autrement.
Dans cet article, je commence par explorer deux exemples triviaux de programmation dynamique. Ensuite, je passe sur un problème tout aussi accessible, mais dont l&amp;rsquo;achèvement optimal demandera l&amp;rsquo;utilisation d&amp;rsquo;une structure Data.</description>
        
        <dc:creator>Simon Désaulniers</dc:creator>
        
        
        <media:content url="https://sim590.github.ioimages/haskell.png" medium="image"><media:title type="html">meta image</media:title></media:content>
        
          
            
              <category>Séquence de Collatz</category>
            
          
            
              <category>Data.Array</category>
            
          
            
              <category>nombre triangulaire</category>
            
          
        
        
          
            
              <category>Algorithmique</category>
            
          
            
              <category>Haskell</category>
            
          
            
              <category>Mémoïsation</category>
            
          
            
              <category>Programmation</category>
            
          
            
              <category>Programmation dynamique</category>
            
          
        
        
      </item>
      

    
  </channel>
</rss>