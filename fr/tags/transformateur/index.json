[{"content":" Dès lors qu\u0026rsquo;on découvre les monades et leur utilité, on ne peut faire autrement que de les étudier davantage et trouver les occasions pour les utiliser. Après tout, ils sont des concepts clefs dans l\u0026rsquo;utilisation sérieuse d\u0026rsquo;un langage fonctionnel comme Haskell. Par exemple, on ne peut pas faire d\u0026rsquo;opérations d\u0026rsquo;entrée/sortie si on ne fonctionne pas dans la monade IO.\nUne limitation importante prend forme très rapidement sous nos yeux: il est devient difficile d\u0026rsquo;utiliser plusieurs monades ensembles car on doit forcément les développer pour passer d\u0026rsquo;une monade à l\u0026rsquo;autre. Ce faisant, on doit choisir entre les propriétés d\u0026rsquo;une monade ou l\u0026rsquo;autre et on ne peut donc pas bénéficier des différents monades en même temps. Les transformateurs de monades visent justement régler ce problème de manière à fournir une écriture finale satisfaisante autant au niveau sémantique que pour l\u0026rsquo;organisation logique du code.\nCas typique de Maybe Par exemple, admettons la fonction suivante récupérant un mot de passe:\n1 2 3 4  getPassWord :: IO String getPassWord = do putStr \u0026#34;Entrez votre mot de passe: \u0026#34; getLine   Ici, on récupère un mot de passe simplement en lisant la ligne à l\u0026rsquo;entrée standard. Et si la fonction devait pouvoir retourner un résultat d\u0026rsquo;erreur si le mot de passe ne répond pas à un certain critère? Par exemple, on pourrait demander que le mot de passe soit entre 6 et 8 caractères. Dans un premier temps, on pourrait imaginer pouvoir écrire la chose suivante:\n1 2 3 4 5 6 7  getPassword :: IO (Maybe String) getPassword = do putStr \u0026#34;Entrez votre mot de passe: \u0026#34; pwd_candidate \u0026lt;- getLine let n = length pwd_candidate if n \u0026gt;= 6 \u0026amp;\u0026amp; n \u0026lt;= 8 then return (Just pwd_candidate) else return Nothing   Dès lors, on se rend contre d\u0026rsquo;une chose: il est impossible d\u0026rsquo;utiliser ici des fonctions telles que guard :: Alternative f =\u0026gt; Bool -\u0026gt; f () de façon à court-circuiter l\u0026rsquo;exécution du code autrement qu\u0026rsquo;en exécutant directement l\u0026rsquo;instruction dans la monade Maybe. Ceci est d\u0026rsquo;autant plus apparent si on s\u0026rsquo;impose plusieurs conditions d\u0026rsquo;échec. Disons maintenant que le mot de passe devrait aussi ne contenir que des lettres [a-zA-Z], alors on aurait donc:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  letters :: [Char] letters = [\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;] ++ [\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;] getPassword :: IO (Maybe String) getPassword = do putStr \u0026#34;Entrez votre mot de passe: \u0026#34; pwd_candidate \u0026lt;- getLine let n = length pwd_candidate s \u0026lt;- return $ do guard (n \u0026gt;= 6 \u0026amp;\u0026amp; n \u0026lt;= 8) guard (all (`elem` letters) pwd_candidate) return pwd_candidate putStrLn \u0026#34;Success!\u0026#34; return s   Ici, le court-circuit de guard n\u0026rsquo;est pas effectif sur le reste de la fonction comme il l\u0026rsquo;est à l\u0026rsquo;intérieur du bloc do lui-même:\n1 2 3 4 5 6 7 8  -- ... -- n == 10 s \u0026lt;- return $ do guard (n \u0026gt;= 6 \u0026amp;\u0026amp; n \u0026lt;= 8) -- sera exécuté guard (all (`elem` letters) pwd_candidate) -- ne sera pas exécuté en -- vertue de la définition de la monade Maybe return pwd_candidate -- ...   Or, on aurait aimé que le message Success! ne s\u0026rsquo;affiche pas dans le cas d\u0026rsquo;un échec. En d\u0026rsquo;autres termes, on aurait aimé ici bénéficier des propriétés de la monade Maybe en plus des propriétés de la monade IO.\nCas typique de State Supposons qu\u0026rsquo;on veuille écrire une fonction faisant la génération d\u0026rsquo;un nombre dans un intervalle tout en assurant que l\u0026rsquo;intervalle n\u0026rsquo;ait pas une taille plus élevé qu\u0026rsquo;un certain maximum. On pourrait imaginer pouvoir écrire la chose suivante:\n1 2 3 4 5 6 7 8 9 10 11  generateRandomNumberInInterval :: Int -\u0026gt; Int -\u0026gt; State StdGen Int generateRandomNumberInInterval a b = do g \u0026lt;- get let (r :: Int, ng) = randomR (a, b) g put ng return r randomNumberInInterval :: Int -\u0026gt; Int -\u0026gt; Maybe (State StdGen Int) randomNumberInInterval a b = do guard (a - b + 1 \u0026lt;= 256) return $ generateRandomNumberInInterval a b   Ceci dit, admettons maintenant qu\u0026rsquo;on veuille retrouver un nombre aléatoire dans l\u0026rsquo;intervalle \\([a, x]\\) où \\(x\\) est un nombre aléatoire entre \\(a\\) et \\(b\\). On devrait donc plutôt écrire randomNumberInInterval comme:\n1 2 3 4 5 6  randomNumberInInterval :: Int -\u0026gt; Int -\u0026gt; Maybe (State StdGen Int) randomNumberInInterval a b = do guard (a - b + 1 \u0026lt;= 256) return $ do x \u0026lt;- generateRandomNumberInInterval a b generateRandomNumberInInterval a x   En ajoutant maintenant la restriction \\(x \\neq \\frac{a + b}{2}\\), alors nous sommes bloqués. Il est impossible d\u0026rsquo;avoir accès à la valeur x à l\u0026rsquo;intérieur du contexte de la monade Maybe (hors du contexte de la monade State du bloc do). C\u0026rsquo;est-à-dire qu\u0026rsquo;on ne peut pas écrire:\n1 2 3 4 5 6  randomNumberInInterval :: Int -\u0026gt; Int -\u0026gt; Maybe (State StdGen Int) randomNumberInInterval a b = do guard (a - b + 1 \u0026lt;= 256) x \u0026lt;- return $ generateRandomNumberInInterval a b -- Invalide!!! guard (x /= (a + b) `div` 2) return $ generateRandomNumberInInterval a x -- Invalide!!!   Car ici, x a le type State StdGen Int et non pas Int. C\u0026rsquo;est donc dire que nous aurions ici préféré avoir un contexte d\u0026rsquo;exécution qui réunirait encore ici une fois la monade Maybe et la monade State.\nLes transformateurs Les transformateurs sont des monades visant à fournir la qualité principale de composition de monade. Cela est fait en fournissant une instance pour la classe suivante:\n1 2  class MonadTrans t where lift :: Monad m =\u0026gt; m a -\u0026gt; t m a   L\u0026rsquo;idée étant de permettre de faire vivre dans la monade t une opération originant de la monade m (voir la documentation pour plus d\u0026rsquo;information).\nPar convention, les transformateurs de monade sont notés selon leur monade correspondante suivi du préfixe T. Par exemple, la monade Maybe possède le transformateur de monade MaybeT. On retrouve aussi la même chose pour les différentes monades usuelles suivantes:\n   Monade Transformateur     Maybe MaybeT   State StateT   Reader ReaderT   Writer WriterT   \u0026hellip; \u0026hellip;T    Un transformateur est normalement défini comme un newtype paramétré minimalement avec une variable m où m est une monade. Par exemple, le transformateur MaybeT est défini comme:\n1  newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }   De façon standard, on nomme le contenu du type par run{Monade}T où {Monade} est le nom de la monade pour laquelle on créé le transformateur. Ceci permet donc de développer la monade au niveau de l\u0026rsquo;appelant.\nPar exemple,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  theFilePath :: String theFilePath = \u0026#34;/home/haskell/transformateurs.bizzbizz\u0026#34; decode :: String -\u0026gt; Maybe String decode = undefined -- La définition ici pourrait échouer et donc ne pas fournir -- de chaîne de caractères en sortie, d\u0026#39;où le type `Maybe String` decodeFile :: String -\u0026gt; MaybeT IO String decodeFile path = do h \u0026lt;- lift $ openFile path ReadMode s \u0026lt;- lift $ hGetContents h MaybeT . return $ decode s main :: IO () main = do mDecodedFileContent \u0026lt;- runMaybeT (decodeFile theFilePath) putStrLn $ fromMaybe \u0026#34;oops... Le fichier n\u0026#39;a pas pu être décodé...\u0026#34; mDecodedFileContent   Dans ce cas-ci, runMaybeT (decodeFile theFilePath) a le type précis IO (Maybe String). Le lecteur devrait remarquer maintenant qu\u0026rsquo;en spécifiant le type de retour MaybeT IO String sur la fonction decodeFile, on a orchestré l\u0026rsquo;exécution de Maybe par dessus de la monade IO. En général, les transformateurs permettent de créer des piles de monades. Ces piles sont ensuite développées du haut vers le bas. Par exemple, le type suivant:\n1  MaybeT (StateT s (Reader r)) a   représente la pile de monades suivante:\nMaybe State s Reader r Afin de développer cette pile, on devrait donc appeler les fonctions runMaybeT, runStateT, runReaderT dans l\u0026rsquo;ordre afin d\u0026rsquo;obtenir le type suivant:\n1  ((Maybe a), s)   (voir les définitions respectives pour runReaderT et runStateT).\nMaybeT Ramenons la définition de MaybeT:\n1  newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }   Naturellement, comme MaybeT est une monade, il fournit une instance aux différentes classes de type Functor, Applicative et Monad. Voici la définition de l\u0026rsquo;instance de MonadTrans:\n1 2 3  instance MonadTrans MaybeT where lift :: m a -\u0026gt; MaybeT m a lift = MaybeT . liftM Just   De cette définition, on comprend que toute opération dans une monade m peut être enveloppée dans la monade MaybeT. Pour y voir encore plus claire, regardons la définition de l\u0026rsquo;instance de la classe de type Monad pour MaybeT:\n1 2 3 4 5 6  instance Monad (MaybeT m) where mbta \u0026gt;\u0026gt;= f = MaybeT $ do ma \u0026lt;- runMaybeT mbta case ma of Just a -\u0026gt; runMaybeT $ f a Nothing -\u0026gt; return Nothing   On voit que dans la monade MaybeT la monade m s\u0026rsquo;exécute en premier en prenant mbta et en le passant dans le bloc do pour le développer comme ma, une variable de type Maybe a. Ce faisant, à ce point-ci, l\u0026rsquo;effet de la monade m a déjà eu lieu. En suite, le reste de l\u0026rsquo;exécution du bloc do consiste en l\u0026rsquo;effet contribué par la monade MaybeT dans la pile de monades:\n1 2 3  case ma of Just a -\u0026gt; runMaybeT $ f a Nothing -\u0026gt; return Nothing   Il s\u0026rsquo;agit effectivement de l\u0026rsquo;effet de Maybe, c.-à-d. un court-circuit d\u0026rsquo;exécution dans le cas où la valeur ma est Nothing. Sinon, la suite représentée par la fonction f est exécutée puis enveloppée à nouveau dans le contexte de la monade MaybeT.\nRetour sur l\u0026rsquo;exemple initial pour MaybeT\nRappelons premièrement l\u0026rsquo;état final que nous avions:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  letters :: [Char] letters = [\u0026#39;a\u0026#39;..\u0026#39;z\u0026#39;] ++ [\u0026#39;A\u0026#39;..\u0026#39;Z\u0026#39;] getPassword :: IO (Maybe String) getPassword = do putStr \u0026#34;Entrez votre mot de passe: \u0026#34; pwd_candidate \u0026lt;- getLine let n = length pwd_candidate s \u0026lt;- return $ do guard (n \u0026gt;= 6 \u0026amp;\u0026amp; n \u0026lt;= 8) guard (all (`elem` letters) pwd_candidate) return pwd_candidate putStrLn \u0026#34;Success!\u0026#34; return s   Comme mentionné plutôt, nous aurions voulu que l\u0026rsquo;exécution de guard ait un effet sur l\u0026rsquo;instruction putStrLn. Nous pouvons maintenant le faire comme suit:\n1 2 3 4 5 6 7 8 9  getPassword :: MaybeT IO String getPassword = do lift $ putStr \u0026#34;Entrez votre mot de passe: \u0026#34; pwd_candidate \u0026lt;- lift getLine let n = length pwd_candidate guard (n \u0026gt;= 6 \u0026amp;\u0026amp; n \u0026lt;= 8) guard (all (\\ c -\u0026gt; elem c letters) pwd_candidate) lift $ putStrLn \u0026#34;Success!\u0026#34; return pwd_candidate   StateT Le transformateur correspondant à la monade State est défini comme suit:\n1  newtype StateT s m a = StateT { runStateT :: s -\u0026gt; m (a,s) }   Pour comparaison, observons la définition de la monde State:\n1  newtype State s m a = State { runState :: s -\u0026gt; (a,s) }   On voit tout de suite la similitude entre les deux. En fait, tout comme MaybeT, la définition de la monade est la même à la différence prêt qu\u0026rsquo;on a enveloppé le type de retour dans une monade arbitraire.\nComme MaybeT, le transformateur StateT possède une instance pour la classe de type MonadTrans, ce qui permet donc d\u0026rsquo;appeler lift à l\u0026rsquo;intérieur de son contexte d\u0026rsquo;exécution. Pour notre exemple initialisé plus haut, on a donc:\n1 2 3 4 5 6  randomNumberInInterval :: Int -\u0026gt; Int -\u0026gt; MaybeT (State StdGen) Int randomNumberInInterval a b = do guard (a - b + 1 \u0026lt;= 256) x \u0026lt;- lift $ generateRandomNumberInInterval a b guard (x /= (a + b) `div` 2) lift $ generateRandomNumberInInterval a x   C\u0026rsquo;est exactement ce qu\u0026rsquo;on souhait faire plus haut, à la différence près que les instructions (fautives) return ont été remplacées par lift. On bénéficie donc ici des effets des deux monades en simultané, c.-à-d. que le fil d\u0026rsquo;exécution est régit par les effets de Maybe via les instructions guard et finalement lift permet de récupérer la valeur x. De plus, l\u0026rsquo;état s retourné par le premier appel de generateRandomNumberInInterval est fournit en entrée au second appel. En d,autres termes, l\u0026rsquo;état s est partagé.\nClasses de types La bibliothèques MTL fournit certaines classes de type permettant d\u0026rsquo;alléger l\u0026rsquo;écriture des piles de monades dans les signatures en remplaçant les types concrets de transformateurs par des contraintes sur les classes de type. Par exemple, la classe de type MonadState est analogue à StateT:\n1 2 3  class Monad m =\u0026gt; MonadState s m | m -\u0026gt; s where get :: m s put :: s -\u0026gt; m ()   Ceci permet donc d\u0026rsquo;écrire la fonction de l\u0026rsquo;exemple sur StateT comme suit:\n1 2 3 4 5 6  randomNumberInInterval :: MonadState StdGen m =\u0026gt; Int -\u0026gt; Int -\u0026gt; MaybeT m Int randomNumberInInterval a b = do guard (a - b + 1 \u0026lt;= 256) x \u0026lt;- lift $ generateRandomNumberInInterval a b guard (x /= (a + b) `div` 2) lift $ generateRandomNumberInInterval a x   moyennant qu\u0026rsquo;on adapte la signature de generateRandomNumberInInterval comme suit:\n1  generateRandomNumberInInterval :: MonadState StdGen m =\u0026gt; Int -\u0026gt; Int -\u0026gt; m Int   On peut tester le résultat comme suit:\n1 2 3 4 5  test :: IO () test = do g \u0026lt;- newStdGen (mi, s) \u0026lt;- runStateT (runMaybeT $ randomNumberInInterval\u0026#39; 0 1) g print mi   La trace de plusieurs appels à cette fonction pourrait donner quelque chose comme:\n*Main\u0026gt; test Nothing *Main\u0026gt; test Just 1 *Main\u0026gt; test Nothing *Main\u0026gt; test Nothing *Main\u0026gt; test Just 0 *Main\u0026gt; test Just 0 *Main\u0026gt; test Just 0 *Main\u0026gt; test Just 1 *Main\u0026gt; test Nothing *Main\u0026gt; test Nothing On voit bien qu\u0026rsquo;une fois sur deux (en moyenne), le retour de la fonction est 0 puisqu\u0026rsquo;une fois sur deux, le premier appel de generateRandomNumberInInterval retourne 0.\nLes classes de types et les piles de monades\nOn pourrait facilement arguer qu\u0026rsquo;il n\u0026rsquo;y a pas un grand avantage à utiliser la classe de type dans l\u0026rsquo;exemple précédent. Par contre, il est à noter qu\u0026rsquo;au lieu d\u0026rsquo;utiliser StateT pour satisfaire la contrainte MonadState il est possible de fournir une monade quelconque fournissant une instance pour la classe.\nEn particulier, les différents transformateurs de la bibliothèque MTL fournissent des instances conditionnelles à chacune des classes lorsque le transformateur en question ne fournit pas une instance concrète. Une instance conditionnelle est une instance qui se réalise si la monade sous-jacente fournit une instance concrète. Par exemple, dans la bibliothèque MTL, on retrouve:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  instance MonadState s m =\u0026gt; MonadState s (MaybeT m) where get = lift get put = lift . put state = lift . state instance MonadState s m =\u0026gt; MonadState s (ReaderT r m) where get = lift get put = lift . put state = lift . state instance (Monoid w, MonadState s m) =\u0026gt; MonadState s (Lazy.WriterT w m) where get = lift get put = lift . put state = lift . state   On voit donc que MaybeT et ReaderT satisfont la classe MonadState, mais seulement si la monade sous-jacente m fournit elle-même une instance pour MonadState. On voit donc qu\u0026rsquo;on peut facilement empiler ReaderT, MaybeT, WriterT et d\u0026rsquo;autres transformateurs ensemble tout en satisfaisant la contrainte. Notamment, dans notre exemple:\n1  randomNumberInInterval :: MonadState StdGen m =\u0026gt; Int -\u0026gt; Int -\u0026gt; MaybeT m Int   m n\u0026rsquo;est pas contraint d\u0026rsquo;être StateT ni State. En fait, cela peut être une pile arbitrairement élevée de monades fournissant une instance à MonadState. Le tout fonctionnera tant et aussi longtemps qu\u0026rsquo;au moins une monade dans la pile fournit une instance concrète de la classe MonadState. Donc, ici m pourrait aussi bien correspondre à ReaderT r (WriteT w (StateT s m)) qu\u0026rsquo;à simplement StateT s m.\nConclusion Les monades sont une pièce angulaire de la programmation fonctionnelle. Or, le besoin se fait vite ressentir de combler le manque de composition des monades lorsqu\u0026rsquo;on développe en Haskell. Les transformateurs permettent de combler ce manque de façon à rendre l\u0026rsquo;écriture du code plus puissante. Les classes de type de la bibliothèque MTL viennent compléter avec une touche de générécité ce qui augmente considérablement les capacités des transformateurs. En somme, les transformateurs sont un incontournable de la programmation en Haskell.\n","description":"","id":7,"section":"haskell","tags":["Transformateur","Monade","Composition"],"title":"Transformateurs: composition de monades","uri":"https://sim590.github.io/fr/haskell/transformateurs/"},{"content":"Dans cet article, je souhaite introduire le programmeur à la monade Maybe. Je compte le faire en utilisant le langage Haskell puisqu\u0026rsquo;il s\u0026rsquo;agit du langage fonctionnel que je maîtrise le mieux et que je le considère très expressif et accessible. Afin de démontrer les bénéfices de la monade et des concepts d\u0026rsquo;Haskell, je vais comparer ceux-ci aux méthodes usuelles du langage C++.\nEn une phrase, la monade Maybe peut être vue comme un design pattern de gestion des cas d\u0026rsquo;erreur ou d\u0026rsquo;exception. Je vais donc utiliser un exemple fictif et peu réaliste, mais simple, qui permet de capturer l\u0026rsquo;idée générale. Disons qu\u0026rsquo;on a une liste de contacts pour lesquels on souhaite exécuter un traitement. Cependant, on décide que, dans la région du programme où on implémente le code associé à cette liste de contact, une opération qui échoue sur un contact devrait arrêter le fil d\u0026rsquo;exécution du programme.\nPour débuter, définissons quelques bases:\n1 2 3 4 5 6 7 8 9 10 11 12 13  struct Contact { std::string nom {}; std::string numero {}; }; using PaireNomNum = std::pair\u0026lt;std::string, std::string\u0026gt;; std::vector\u0026lt;std::pair\u0026lt;std::string, std::string\u0026gt;\u0026gt; numeros { {\u0026#34;Jean\u0026#34;, \u0026#34;5143482387\u0026#34;} , {\u0026#34;Michaël\u0026#34;, \u0026#34;5143522489\u0026#34;} , {\u0026#34;Roger\u0026#34;, \u0026#34;5143732279\u0026#34;} , {\u0026#34;Charles\u0026#34;, \u0026#34;5143783211\u0026#34;} };   Les définitions ci-haut peuvent être réécrites en Haskell comme suit:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  type Nom = String type NumeroDeTelephone = String data Contact = Contact { nomContact :: Nom , numeroContact :: NumeroDeTelephone } deriving Show numeros :: [(Nom, NumeroDeTelephone)] numeros = [ (\u0026#34;Jean\u0026#34;, \u0026#34;5143482387\u0026#34;) , (\u0026#34;Michaël\u0026#34;, \u0026#34;5143522489\u0026#34;) , (\u0026#34;Roger\u0026#34;, \u0026#34;5143732279\u0026#34;) , (\u0026#34;Charles\u0026#34;, \u0026#34;5143783211\u0026#34;) ]   On va utiliser ces définitions tout au long de cet article.\nContexte Disons qu\u0026rsquo;on souhaite premièrement retrouver un numéro dans la liste de contacts. Bien sûr, il faut prendre en compte que le nom passé en paramètre permettant de retrouver le numéro pourrait ne pas exister dans la liste. Il s\u0026rsquo;agit là d\u0026rsquo;un cas d\u0026rsquo;erreur. En C++, on pourrait écrire:\n1 2 3 4 5 6  std::vector\u0026lt;PaireNomNum\u0026gt;::iterator retrouverNumero(const std::string\u0026amp; nom) { return std::find_if(numeros.begin(), numeros.end(), [nom](const auto\u0026amp; nomnum) { return nomnum.first == nom; }); }   Ici, on remarque que le retour de la valeur std::end(numeros) se traduit par la non-présence d\u0026rsquo;un nom dans la liste de contacts.\nEn Haskell, on écrirait plutôt:\n1 2 3  retrouverNumero :: Nom -\u0026gt; Maybe NumeroDeTelephone retrouverNumero nom0 = snd \u0026lt;$\u0026gt; find (\\ (nom, _) -\u0026gt; nom == nom0) numeros   Ici, find :: Traversable t =\u0026gt; (a -\u0026gt; Bool) -\u0026gt; t a -\u0026gt; Maybe a retrouve un élément depuis un type «traversable» (comme une liste) en utilisant le prédicat a -\u0026gt; Bool pour décider si l\u0026rsquo;élément correspond. Dans notre contexte, find prend la signature concrète suivante:\n1 2 3  ((Nom, NumeroDeTelephone) -\u0026gt; Bool) -\u0026gt; [(Nom, NumeroDeTelephone)] -\u0026gt; Maybe (Nom, NumeroDeTelephone)   Notre fonction retrouverNumero parcourt donc la liste des numéros en cherchant la paire dont le premier élément correspond. Sans find, on pourrait réécrire le code plus haut comme suit:\n1 2 3 4 5 6 7 8  retrouverNumero :: Nom -\u0026gt; Maybe NumeroDeTelephone retrouverNumero nom0 = parcourir numeros where parcourir [] = Nothing -- on ne retrouve pas le nom parcourir ((nom, num) : resteDesNumeros) | nom0 == nom = Just num -- on a retrouvé le nom | otherwise = parcourir resteDesNumeros   Ici, quand on ne retrouve pas le nom, on renvoie Nothing. Sinon, si on le retrouve, on renvoie Just num, ce qui est simplement le numéro enveloppé par le constructeur Just.\nPour mieux comprendre, regardons la définition du type Maybe:\n1 2  data Maybe a = Just a | Nothing   On voit donc qu\u0026rsquo;un type Maybe est un type de données qui admet deux états: un premier admissible comportant une donnée abstraite de type a et un second nommé Nothing et sans paramètre. Ce second état traduit une valeur non admissible. C\u0026rsquo;est analogue au concept de la valeur nullptr dans C++, mais en bien plus puissant et ce en raison du concept même de monade.\nPropagation des erreurs Il est commun de propager un cas d\u0026rsquo;erreur depuis le haut d\u0026rsquo;une pile d\u0026rsquo;appels de fonctions jusqu\u0026rsquo;à l\u0026rsquo;endroit où on souhaite gérer l\u0026rsquo;erreur comme tel. Par exemple, dans notre contexte des contacts, on pourrait vouloir construire une structure Contact après avoir retrouvé le numéro du contact. En C++, on écrirait donc maintenant:\n1 2 3 4 5 6 7  Contact* retrouverContact(const std::string\u0026amp; nom) { auto nomnum = retrouverNumero(nom); if (nomnum != std::end(numeros)) { return new Contact {nom, nomnum-\u0026gt;second}; } else return nullptr; }   Encore une fois, on doit gérer le cas où le numéro n\u0026rsquo;est pas retrouvé. Ceci se traduit par la vérification à savoir si retrouverNumero a retourné std::end(numeros) ou non. On gère donc ici explicitement ce cas. En Haskell, pas du tout!! On peut simplement demander à la monade Maybe de le faire pour nous:\n1 2 3 4 5  retrouverContact :: Nom -\u0026gt; Maybe Contact retrouverContact nom = do numero \u0026lt;- retrouverNumero nom return $ Contact nom numero   En effet, ce bout de code est complètement équivalent au bout de code C++, c\u0026rsquo;est-à-dire que nous retrouvons un numéro associé au nom et si on ne le retrouve pas, alors on propagera plus bas dans la pile d\u0026rsquo;appels de fonction la valeur signifiant le cas d\u0026rsquo;erreur. Or, ici le développeur Haskell n\u0026rsquo;a écrit aucune instruction de gestion d\u0026rsquo;erreur. Le tout est propagé par la monade Maybe.\nLa monade Maybe Je rappelle maintenant la définition d\u0026rsquo;une classe Monad:\n1 2  class Applicative m =\u0026gt; Monad m where (\u0026gt;\u0026gt;=) :: m a -\u0026gt; (a -\u0026gt; m b) -\u0026gt; m b   Une monade traduit l\u0026rsquo;enchaînement d\u0026rsquo;exécution de fonctions. L\u0026rsquo;opérateur \u0026gt;\u0026gt;= est nommé bind en anglais, ce qui revient au concept d\u0026rsquo;enchaînement ou de tuyautage en séquence de fonctions. Pour la simplicité de l\u0026rsquo;article, omettons de remarquer la présence de la restriction Applicative m. Si cela intéresse le lecteur, celui-ci peut lire à ce sujet ici.\nOn peut voir une monade comme une classe de type permettant de transformer un état en un second état par l\u0026rsquo;application d\u0026rsquo;une fonction. Dans la signature, le premier état est m a. L\u0026rsquo;opérateur \u0026gt;\u0026gt;= se charge d\u0026rsquo;appliquer la fonction a -\u0026gt; m b sur le contenu du premier état m a pour dériver le dernier état m b.\nDans notre cas, la monade Maybe est définie comme suit:\n1 2 3  (\u0026gt;\u0026gt;=) :: Maybe a -\u0026gt; (a -\u0026gt; Maybe b) -\u0026gt; Maybe b Nothing \u0026gt;\u0026gt;= _ = Nothing Just x \u0026gt;\u0026gt;= f = f x   Ceci veut donc dire que si le premier état correspondait à l\u0026rsquo;état d\u0026rsquo;erreur Nothing, alors la fonction de transition d\u0026rsquo;état a -\u0026gt; Maybe b ne sera jamais exécutée et on renverra Nothing. Ceci fournit une abstraction de la gestion d\u0026rsquo;erreur très utile afin de réduire les occurrences d\u0026rsquo;écriture d\u0026rsquo;instructions redondantes par le développeur.\nLes blocs «do» Le bloc do est du simple sucre syntaxique permettant d\u0026rsquo;écrire une succession d\u0026rsquo;opérations dans une monade sans écrire \u0026gt;\u0026gt;=. Au fond, un bloc de la forme suivante:\n1 2 3  do a \u0026lt;- ma fa a   correspond exactement à ma \u0026gt;\u0026gt;= fa, ce qui mène au type m b dans la monade m. Ce faisant, l\u0026rsquo;exemple de retrouverContact aurait pu être réécrit comme:\n1 2 3 4 5 6  retrouverContact :: Nom -\u0026gt; Maybe Contact retrouverContact nom = retrouverNumero nom \u0026gt;\u0026gt;= creerContact where creerContact :: NumeroDeTelephone -\u0026gt; Maybe Contact creerContact numero = return $ Contact nom numero   Ici, j\u0026rsquo;ai utilisé un bloc where pour nommer la fonction creerContact et j\u0026rsquo;ai aussi apposé la signature de celle-ci afin de fournir un maximum de détails utiles à la compréhension.\nPropagation d\u0026rsquo;erreur au sein d\u0026rsquo;une même fonction Lorsqu\u0026rsquo;on propage une erreur, on peut vouloir empêcher l\u0026rsquo;exécution du reste d\u0026rsquo;une fonction en plus de renvoyer l\u0026rsquo;erreur plus bas dans la pile d\u0026rsquo;appels. Disons qu\u0026rsquo;on souhaite effectuer deux tâches lors du traitement d\u0026rsquo;un contact. On pourrait premièrement vouloir afficher le contact et ensuite changer son numéro de téléphone.\n1 2 3 4 5 6 7 8 9  bool afficherContact(const std::string\u0026amp; nom) { auto contact = retrouverContact(nom); if (contact) { std::cout \u0026lt;\u0026lt; \u0026#34;Nom: \u0026#34; \u0026lt;\u0026lt; contact-\u0026gt;nom \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Numero: \u0026#34; \u0026lt;\u0026lt; contact-\u0026gt;numero \u0026lt;\u0026lt; std::endl; return true; } else return false; }   Ici, on recherche le contact et si on le retrouve, on affiche le contact. On écrit explicitement la gestion des deux cas duaux.\n1 2 3 4 5 6 7 8  bool changerNumero(const std::string\u0026amp; nom, const std::string\u0026amp; numero) { auto nomnum = retrouverNumero(nom); if (nomnum != numeros.end()) { nomnum-\u0026gt;second = numero; return true; } else return false; }   Idem pour le cas où on change le nom: les cas d\u0026rsquo;erreurs sont traités et on change le nom si possible.\nEn Haskell:\n1 2 3 4 5  afficherContact :: Nom -\u0026gt; MaybeT IO () afficherContact nom = do contact \u0026lt;- MaybeT $ pure $ retrouverContact nom lift $ print contact   Ici, on retrouve le contact puis on l\u0026rsquo;affiche à l\u0026rsquo;écran. Il est à noter que nous avons passé maintenant du type Maybe à MaybeT IO. Le lecteur peut ignorer ce détail et considérer que la monade MaybeT IO se comporte exactement comme Maybe. Pour plus de détail, consultez mon article sur les transformateurs qui sortira bientôt. Finalement, le lecteur peut voir les instructions MaybeT, pure et lift que comme de la colle syntaxique qui permet d\u0026rsquo;obtenir les bons types. Ceci est nécessaire afin d\u0026rsquo;exécuter des instructions de la monade IO dans la monade Maybe.\nNOTE: Comme Contact est un type pour lequel on a utilisé l\u0026rsquo;instruction deriving Show, le compilateur nous fournit déjà des fonctions de base pour afficher le contact.\n1 2 3 4 5 6  changerNumero :: Nom -\u0026gt; NumeroDeTelephone -\u0026gt; Maybe (Nom, NumeroDeTelephone) changerNumero nom nouvnum = do void $ retrouverContact nom return (nom, nouvnum)   Quoi qu\u0026rsquo;il en soit, le lecteur peut très bien voir qu\u0026rsquo;aucune instruction en rapport à la gestion d\u0026rsquo;erreur n\u0026rsquo;est faite, mais il doit se rappeler aussi que c\u0026rsquo;est la monade Maybe (et MaybeT IO) qui s\u0026rsquo;en charge pour le développeur!\nMaintenant, si on souhaite traiter ces fonctions pour un contact, on pourrait écrire la fonction suivante:\n1 2 3 4 5 6 7 8 9 10  bool traiterContact(const std::string\u0026amp; nom, const std::string\u0026amp; nouv_numero) { bool succes = true; if (succes) { succes = afficherContact(nom); } if (succes) { succes = changerNumero(nom, nouv_numero); } return succes; }   Ici, si on veut empêcher l\u0026rsquo;exécution de la seconde fonction changerNumero dans le cas d\u0026rsquo;une erreur rencontrée dans afficherContact, on doit écrire tout ce code qui éloigne le lecteur des détails importants lors de sa lecture. On aurait aimé pouvoir écrire quelque chose comme:\n1 2  afficherContact(nom); changerNumero(nom, nouv_numero);   puisque c\u0026rsquo;est bien ce qui importe ici. Or ce n\u0026rsquo;est pas possible si on veut encoder le comportement désiré. En Haskell, c\u0026rsquo;est automatique grâce à la monade Maybe (ici MaybeT):\n1 2 3 4 5 6  traiterContact :: Nom -\u0026gt; NumeroDeTelephone -\u0026gt; MaybeT IO (Nom, NumeroDeTelephone) traiterContact nom nouvnum = do afficherContact nom MaybeT . pure $ changerNumero nom nouvnum   Des erreurs en boucle Et si on souhaitait exécuter notre traitement pour une liste de contacts? Par exemple, si on souhaitait changer le numéro de téléphone pour la chaîne de caractères vide, alors on écrirait possiblement:\n1 2 3 4 5 6 7 8 9 10 11  void numeros_a_vide(const std::vector\u0026lt;std::string\u0026gt;\u0026amp; noms) { bool succes = true; for (const auto\u0026amp; nom : noms) { if (succes) { succes = traiterContact(nom, \u0026#34;\u0026#34;); if (not succes) { std::cout \u0026lt;\u0026lt; \u0026#34;Erreur!! Un contact est introuvable..\u0026#34; \u0026lt;\u0026lt; std::endl; } } } }   Le lecteur voit tout de suite comment on est forcé d\u0026rsquo;écrire du code redondant traduisant la gestion d\u0026rsquo;erreur. En Haskell ?\n1 2 3 4 5 6 7 8 9  numerosAVide :: [Nom] -\u0026gt; IO [(Nom, NumeroDeTelephone)] numerosAVide noms = do mcontacts \u0026lt;- forM noms $ \\ nom -\u0026gt; do mc \u0026lt;- runMaybeT $ (`traiterContact` \u0026#34;\u0026#34;) nom when (isNothing mc) $ putStrLn \u0026#34;Erreur!! Un contact est introuvable..\u0026#34; return mc return . catMaybes $ takeWhile isJust mcontacts   Et bien, on ne fait qu\u0026rsquo;exécuter traiterContact pour tous les noms dans la liste noms, on récupère le résultat dans mcontacts. Décortiquons\u0026hellip;\n1 2 3 4 5  forM noms $ \\ nom -\u0026gt; do mc \u0026lt;- runMaybeT $ (`traiterContact` \u0026#34;\u0026#34;) nom when (isNothing mc) $ putStrLn \u0026#34;Erreur!! Un contact est introuvable..\u0026#34; return mc   Ce bloc effectue un traitement pour chaque nom dans la liste. Il exécute le traitement pour le contact et récupère le résultat de type Maybe (Nom, NumeroDeTelephone). Si le résultat est dans l\u0026rsquo;état Nothing, alors on affiche un message d\u0026rsquo;erreur. Finalement, on retourne le résultat.\n1  takeWhile isJust mcontacts   Cette dernière instruction parcourt la liste mcontacts de type [Maybe (Nom, NumeroDeTelephone)]. Il s\u0026rsquo;agit du retour d\u0026rsquo;exécution pour chaque nom. Par contre, takeWhile isJust stoppe l\u0026rsquo;itération dès qu\u0026rsquo;une des valeurs dans la liste est Nothing (c.-à-d. que isJust retourne FAUX). Ce faisant, on ne va pas plus loin dans la liste dès qu\u0026rsquo;on rencontre un résultat Nothing. De plus, comme Haskell est paresseux, les itérations de forM plus haut ne seront pas exécutées pour tous les éléments suivant le premier où on a rencontré Nothing.\n1  return . catMaybes   Finalement, on développe tous les résultats de la forme [Just a, Just b, ...] en la forme [a, b, ...]. Il s\u0026rsquo;agit d\u0026rsquo;un détail technique nécessaire afin de retrouver les valeurs en dehors du type Maybe.\nConclusion Haskell est un langage du paradigme fonctionnel contrairement à C++ dont le paradigme principal qui n\u0026rsquo;est pas partagé avec Haskell est le paradigme impératif. Ces deux méthodes de penser la programmation ont mené à des évolutions conceptuelles différentes. Le paradigme fonctionnel a plusieurs bonnes contributions en matière de bonnes pratiques à partager avec les autres. On voit depuis quelques temps les concepts fonctionnels faire leur chemin jusque dans les langages n\u0026rsquo;étant à la base pas fonctionnels. On peut penser à toutes les fonctions standards comme map, filter, fold, etc. Les monades sont une abstraction puissante et sont essentielle dans le paradigme fonctionnel afin de traduire le séquençage d\u0026rsquo;états de manière réellement utilisable. La monade Maybe est un exemple parmi plusieurs de concepts visant à simplifier l\u0026rsquo;écriture du code par la généricité. Heureusement, il y a différents efforts exercés dans le but de faire cheminer ces concepts vers des langages comme C++ et d\u0026rsquo;autres. J\u0026rsquo;encourage donc à découvrir Haskell car c\u0026rsquo;est en quelque sorte une manière d\u0026rsquo;apprendre les fonctions standards de demain qui deviendront dès lors incontournables.\n","description":"","id":8,"section":"haskell","tags":["Maybe","Monad","Gestion d'erreurs","Générécité"],"title":"La monade Maybe","uri":"https://sim590.github.io/fr/haskell/monademaybe/"},{"content":" Je regarde les maisons et condos depuis un certain temps déjà, histoire de sentir un peu ce que l\u0026rsquo;achat implique pour un emprunteur. J\u0026rsquo;ai pris la peine de rechercher différentes informations comme les conditions et les options pour une assurance hypothèque, les frais associés à l\u0026rsquo;habitation (charge de copropriété, taxe scolaire, etc.) ainsi que les taux d\u0026rsquo;intérêt associés à un prêt. J\u0026rsquo;ai donc voulu mettre tout cela en commun afin d\u0026rsquo;avoir un aperçu de mes paiements par mois ainsi que ce que cela engendre sur une période plus longue comme 5, 10 ou même 25 ans. J\u0026rsquo;ai ainsi eu l\u0026rsquo;occasion de faire certains calculs qui seront utiles à plusieurs pour comprendre comment les paiements hypothécaires sont calculés. En particulier, je veux exposer trois calculs clefs dans la prévision des avantages et inconvénients d\u0026rsquo;acheter une propriété versus louer un logement:\n le paiement bancaire régulier (hypothèque et intérêt); le montant de prêt hypothécaire payée sur \\(n\\) années; et l\u0026rsquo;intérêt sur le prêt payé sur \\(n\\) années.  Paiements bancaires Admettons qu\u0026rsquo;on ait un prêt octroyé par une banque pour une habitation. Ce prêt s\u0026rsquo;appelle «prêt hypothécaire». Celui-ci a une valeur qui varie dans le temps puisqu\u0026rsquo;on fait des paiements mensuels afin de le réduire. Notons \\(H_k\\) le montant du prêt hypothécaire courant après la \\(k^{e}\\) année, c.-à-d. ce qui reste à payer après \\(k\\) années de paiement. Le montant du prêt sera donc noté \\(H_0\\). Notons maintenant \\(P\\) le paiement bancaire à faire par année pour arriver à payer notre prêt au fil des années. Il faut bien sûr considérer aussi finalement l\u0026rsquo;intérêt sur le prêt. Notons-le pourcentage associé à l\u0026rsquo;intérêt par année \\(i\\). Bien entendu, \\(i\\) a comme domaine de valeurs l\u0026rsquo;intervalle \\([0,1]\\). De cela, si on souhaitait payer notre prêt en une seule année, on pourrait alors écrire:\n$$ H_0 + iH_0 = P $$\nIci, on lit la relation comme «le paiement à faire est la somme du prêt en plus des intérêts sur le prêt.\nCette relation peut se réécrire comme:\n$$ H_0(i+1) - P = 0 $$\nPour le besoin de la cause, c\u0026rsquo;est la forme qu\u0026rsquo;on garde pour le reste du document. Or, si on souhaitait payer en deux ans, on aurait alors:\n$$ (H_0(i+1) - P)(i+1) - P = 0 $$\nBien sûr! Puisque la seconde année, la somme restante à payer, c\u0026rsquo;est-à-dire le montant hypothécaire en plus des intérêts sur la première année avec le tout retranché du premier paiement, était \\(S_0 = H_0(i+1) - P\\). Dans l\u0026rsquo;expression ci-haut, on voit bien que cette quantité a été multipliée par \\((i+1)\\), comme c\u0026rsquo;était le cas pour \\(H_0\\) la première année. En fait, on retrouve la même forme que pour la première année si on substitute \\(S_0\\) dans l\u0026rsquo;équation:\n$$ S_0(i+1) - P = 0,\\quad\\text{avec}\\ S_0 = H_0(i+1) - P $$\nNotez bien qu\u0026rsquo;ici, \\(P\\) ne vaut pas la même quantité que dans le scénario où on paie tout en une année. Bien sûr, le montant est un peu plus gros que la moitié de l\u0026rsquo;ancien montant pour \\(P\\). Bref, si on continuait le procédé jusqu\u0026rsquo;à \\(n\\) années, on aurait alors:\n$$ (\u0026hellip;(H_0(i+1) - P)(i+1) - P \u0026hellip;)(i+1) - P = 0 $$\noù \\(H_0\\) (ou \\(P, i\\)) apparaîtrait \\(n\\) fois dans l\u0026rsquo;expression. Reprenons l\u0026rsquo;expression de départ et réordonnançons le tout:\n$$ H_0(i+1) - P = 0 \\implies H_0 = \\frac{P}{(i+1)} $$\nFaisons maintenant la même chose avec la seconde expression:\n$$ H_0 = \\frac{P}{(i+1)} + \\frac{P}{(i+1)^2} $$\nEncore, une fois pour la bonne cause, avec \\(n=3\\):\n$$ H_0 = \\frac{P}{(i+1)} + \\frac{P}{(i+1)^2} + \\frac{P}{(i+1)^3} $$\nOn voit maintenant apparaître un motif régulier! L\u0026rsquo;exposant du dénominateur augmente sur chaque terme et le numérateur reste constant. Lorsque \\(n\\) possède une valeur arbitraire, on peut donc réécrire comme:\n$$ H_0 = P \\left( \\frac{1}{(i+1)} + \\frac{1}{(i+1)^2} + \\frac{1}{(i+1)^3} + \u0026hellip; + \\frac{1}{(i+1)^n} \\right) $$\nNotons maintenant l\u0026rsquo;expression \\(\\frac{1}{i+1}\\) par \\(r\\). La série (partielle) qui se trouve entre parenthèse est bien connue, il s\u0026rsquo;agit de la série géométrique. Il est facile à démontrer qu\u0026rsquo;elle équivaut à l\u0026rsquo;expression suivante:\n$$ \\frac{r - r^{n+1}}{1 - r} $$\nPar conséquent, on peut écrire:\n$$ H_0 = P \\frac{r - r^{n+1}}{1 - r} $$\nCe qui mène évidemment à ce que:\n$$ P = H_0\\frac{1 - r}{r - r^{n+1}} $$\nEt voilà! On a maintenant une formule exacte du paiement bancaire à effectuer à la banque à chaque année si on souhaite régler le paiement de notre hypothèque \\(H_0\\) après \\(n\\) années suivant le taux d\u0026rsquo;intérêt \\(i\\).\nPaiement par mois Cependant, la réalité est un peu différente. On calcule normalement l\u0026rsquo;intérêt chaque mois. Ce faisant, pour déterminer le paiement mensuel, on devrait plutôt faire le même calcul, mais pour \\(m\\) le nombre de mois sur lequel le prêt sera remboursé. Par contre, il faudra ajuster le taux d\u0026rsquo;intérêt en proportion à ce nouveau calcul. On pourrait donc obtenir la formule suivante:\n$$ P = H_0\\frac{1 - r}{r - r^{m+1}},\\quad\\text{avec } r = \\frac{12}{i+12} $$\nPuisque le taux d\u0026rsquo;intérêt est normalement donné sur l\u0026rsquo;année, on divise celui-ci par 12.\nExemple Si on a un hypothèque de 200000 dollars avec un taux d\u0026rsquo;intérêt de 2% par années et qu\u0026rsquo;on souhaite régler le paiement de la dette en 25 ans, alors on aura un paiement régulier par mois à faire de:\n$$ \\begin{align} P \u0026amp;= 200000 \\cdot \\frac{1 - 12\\cdot(12.02)^{-1}}{12\\cdot(12.02)^{-1} - 12^{301}\\cdot(12.02)^{-301}}\\\\\n\u0026amp;= 847.71 \\end{align} $$\nVoilà qui est bien! Ceci dit, connaître le paiement bancaire ne donne pas la totalité de l\u0026rsquo;information intéressante. En effet, soit \\(y_k\\) l\u0026rsquo;intérêt à payer et \\(x_k\\) le montant de prêt hypothécaire payé, tous deux respectivement le \\(k^{e}\\) mois. On a bien sûr la relation suivante pour tout \\(k\\):\n$$ P = y_k + x_k $$\nCe faisant, même si on connaît \\(P\\), on ne sait pas encore quelle portion va dans les intérêts à payer et quelle portion va dans le montant de prêt hypothécaire. Puisque le montant d\u0026rsquo;hypothèque réduit à chaque mois, il est clair que la portion d\u0026rsquo;intérêt dans le paiement régulier \\(P\\) va descendre au fil du temps. Mais comment connaître \\(x_k\\) et \\(y_k\\)? Plus particulièrement, les sommes payées après \\(n\\) mois sont d\u0026rsquo;un grand intérêt (sans jeu de mot :) )!\nPortion d\u0026rsquo;hypothèque du paiement bancaire Dans la dernière section, nous avons déterminé le calcul pour le paiement bancaire régulier à faire par mois pour régler sa dette après \\(m\\) mois. Qu\u0026rsquo;en est-il de la somme d\u0026rsquo;hypothèque payée après \\(m\\) mois? Bien sûr, si on effectue notre paiement sur 25 ans et qu\u0026rsquo;on s\u0026rsquo;interroge à connaître \\(\\sum_{k=1}^{m} x_k\\) pour \\(m = 25 \\cdot 12\\), il est clair que cela est équivalent au montant de prêt hypothécaire final \\(H_0\\) puisqu\u0026rsquo;on a réglé \\(P\\) de sorte qu\u0026rsquo;on ait tout payé après 25 ans. Mais, si on s\u0026rsquo;intéressait plutôt au montant de prêt hypothécaire payée après 5 ans pour un paiement qui s\u0026rsquo;effectue sur 25 ans?\nPremièrement, notons le pourcentage d\u0026rsquo;intérêt proportionnel par mois par \\(\\iota\\). Il est défini par \\(\\frac{i}{12}\\). En reprenant le contexte de la section précédente, on peut écrire que:\n$$ x_1 = P - \\iota{}H_0 $$\npuisque \\(x_1\\) étant le montant de prêt hypothécaire payé le premier mois, on trouve que le paiement bancaire total retranché de l\u0026rsquo;intérêt sur le premier mois, c.-à-d. l\u0026rsquo;intérêt appliquée sur le montant de prêt hypothécaire \\(H_0\\), va nécessairement nous laisser avec la valeur d\u0026rsquo;hypothèque payée ce mois-ci. Bien, mais on aimerait connaître \\(x_1, x_2, \u0026hellip;, x_m\\)\u0026hellip; Essayons de voir ce qui se passe avec \\(x_2\\):\n$$ x_2 = P - \\iota{}H_1 $$\nOr, on sait que \\(H_1 = H_0 - x_1\\) puisque \\(x_1\\) est la première portion d\u0026rsquo;hypothèque payée le premier mois qu\u0026rsquo;on retranche à \\(H_0\\). On peut donc écrire:\n$$ x_2 = P - \\iota{}(H_0 - x_1) = P - \\iota{}(H_0 - P + \\iota{}H_0) $$\nEn réarrangeant le tout, on trouve:\n$$ x_2 = P(1+\\iota{}) - \\iota{}H_0(1+\\iota{}) $$\nSe peut-il qu\u0026rsquo;on tombera sur une formule récurrente cette fois-ci encore? :) Essayons de voir ce que \\(x_3\\) nous réserve:\n$$ x_3 = P - \\iota{}(H_0 - x_2 - x_1) $$\nÉvidemment, \\(H_0 - x_2 - x_1\\) est le montant de prêt hypothécaire le \\(3^{e}\\) mois, donc si on y multiplie le pourcentage d\u0026rsquo;intérêt et qu\u0026rsquo;on retranche cette valeur à \\(P\\), on va trouver le montant de prêt hypothécaire payé le \\(3^{e}\\) mois. En faisant comme pour \\(x_2\\), on retrouve l\u0026rsquo;expression suivante:\n$$ x_3 = P - \\iota{} (H_0 - (P(1+\\iota{}) - \\iota{}H_0(1+\\iota{})) - (P - \\iota{}H_0)) $$\nOn peut alors réécrire le tout comme:\n$$ x_3 = P(1+2\\iota{}+\\iota{}^2) - \\iota{}H_0(1+2\\iota{}+\\iota{}^2) $$\nPar le même procédé, on trouve:\n$$ x_4 = P(1+3\\iota{}+3\\iota{}^2+\\iota{}^3) - \\iota{}H_0(1+3\\iota{}+3\\iota{}^2+\\iota{}^3) $$\net\n$$ x_5 = P(1+4\\iota{}+6\\iota{}^2+4\\iota{}^3+\\iota{}^4) - \\iota{}H_0(1+4\\iota{}+6\\iota{}^2+4\\iota{}^3+\\iota{}^4) $$\nClairement, il y a un motif qui s\u0026rsquo;installe dans ces expressions et qui les lie toutes entre elles. En effet, on peut remarquer deux choses liant \\(x_1, x_2, x_3, x_4\\) et \\(x_5\\):\n le polynôme de l\u0026rsquo;expression \\(x_k\\) est de degré \\(k-1\\). les coefficients de chacun des termes du polynôme respecte une certaine symétrie. D\u0026rsquo;abord, \\(1\\), ensuite \\(1 \u0026mdash; 1\\), puis \\(1 \u0026mdash; 2 \u0026mdash; 1\\), \\(1 \u0026mdash; 3 \u0026mdash; 3 \u0026mdash; 1\\) et enfin \\(1 \u0026mdash; 4 \u0026mdash; 6 \u0026mdash; 4 \u0026mdash; 1\\). La suite des coefficients constitue donc un palindrome, c.-à-d. qu\u0026rsquo;on peut la lire de gauche à droite ou de droite à gauche et la lecture est la même.  Généraliser le premier point est rapide, il s\u0026rsquo;agit d\u0026rsquo;une simple boucle, mais pour ce qui est du second point, c\u0026rsquo;est plus compliqué. Heureusement, il s\u0026rsquo;agit là d\u0026rsquo;un motif connu! On le retrouve dans le fameux Triangle de Pascal:\n1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 Les coordonnées de ce triangle sont déterminées par une combinaison notée \\(C(n, k)\\) ou \\(n \\choose k\\) qui est définie par l\u0026rsquo;expression suivante:\n$$ {n \\choose k} = \\frac{n!}{(n-k)!k!} $$\npour \\(n \\ge 0\\) et \\(0 \\le k \\le n\\). En effet, le premier terme de notre suite, en haut du triangle, à la position \\((0,0)\\), est donc donné par:\n$$ {0 \\choose 0} = \\frac{0!}{(0-0)!0!} = 1 $$\nLa seconde ligne est donc trouvée par:\n$$ {1 \\choose 0}\\ \u0026mdash; {1 \\choose 1} $$\nc.-à-d. \\(1 \u0026mdash; 1\\). On a ensuite les termes de la \\(3^{e}\\) ligne avec:\n$$ {2 \\choose 0}\\ \u0026mdash; {2 \\choose 1}\\ \u0026mdash; {2 \\choose 2} $$\nou encore \\(1 \u0026mdash; 2 \u0026mdash; 1\\). Ce faisant, on peut donc réécrire notre expression pour \\(x_5\\) comme:\n$$ x_5 = (P - \\iota{}H_0)\\left( {4 \\choose 0} +{4 \\choose 1}\\iota{} +{4 \\choose 2}\\iota{}^2 +{4 \\choose 3}\\iota{}^3 +{4 \\choose 4}\\iota{}^4 \\right) $$\noù \\(P - \\iota{}H_0\\) est la factorisation de \\(P\\) et \\(\\iota{}H_0\\) tous deux multipliés au même polynôme. Par conséquent, on a de façon plus succincte:\n$$ x_5 = (P - \\iota{}H_0)\\sum_{k=0}^{4} {4 \\choose k}\\iota{}^{k} $$\nPlus généralement, on écrira donc:\n$$ x_m = (P - \\iota{}H_0)\\sum_{k=0}^{m-1} {m-1 \\choose k}\\iota{}^{k} $$\nOr, l\u0026rsquo;expression \\(\\sum_{k=0}^{m-1} {m-1 \\choose k}\\iota{}^{k}\\) est très connue! Il s\u0026rsquo;agit d\u0026rsquo;un binôme de Newton qui correspond à l\u0026rsquo;expression \\((\\iota{}+1)^{m-1}\\). Ce faisant, on peut réécrire \\(x_m\\) comme suit:\n$$ x_m = (P - \\iota{}H_0)(\\iota{}+1)^{m-1} $$\nExemple En reprenant les hypothèses de l\u0026rsquo;exemple précédent, on a:\n$$ \\begin{cases} H_0 \u0026amp;= 200000 \\\\\ni \u0026amp;= 0.02 \\\\\nP \u0026amp;= 847.71 \\end{cases} $$\nCe faisant, l\u0026rsquo;intérêt par mois est \\(\\iota = \\frac{i}{12}\\). Le paiement d\u0026rsquo;hypothèque le premier mois serait donc:\n$$ x_1 = (P - \\iota{}H_0)(\\iota{}+1)^{1-1} = P - \\iota{}H_0 = 847.71 - \\frac{0.02}{12} \\cdot 200000 = 532.77 $$\nRemarque: Dans le calcul de l\u0026rsquo;exemple, le lecteur devrait remarquer qu\u0026rsquo;à droite de la seconde égalité, l\u0026rsquo;expression de \\(x_1\\) était ramenée à sa plus simple forme, c.-à-d. tel que décrite au départ plus haut dans le document comme \\(P - \\iota{}H_0\\). Cette étape a explicitement été laissé afin qu\u0026rsquo;on remarque le bon fonctionnement de la formule, du moins pour le cas \\(m=1\\).\nVoilà qui est bien. Cependant, je dois rappeler au lecteur que cette expression ne nous fournit que la valeur du montant de prêt hypothécaire à payer le \\(m^{e}\\) mois. Il serait intéressant d\u0026rsquo;obtenir la somme d\u0026rsquo;hypothèque payée au bout de \\(m\\) mois. Notons cette somme au bout de \\(m\\) mois \\(X_m\\). Cela correspond donc à l\u0026rsquo;expression suivante:\n$$ X_m = \\sum_{k=1}^m x_k = (P - \\iota{}H_0) \\sum_{k=1}^m (\\iota{}+1)^{k-1} $$\nCette expression se résoud finalement à:\n$$ X_m = (P - \\iota{}H_0) \\frac{(\\iota{}+1)^m - 1}{\\iota{}} $$\nVérifions! Avec les mêmes hypothèses que précédemment, on devrait arriver, pour \\(m=300\\), à \\(H_0 = 200000\\) puisqu\u0026rsquo;après 25 ans (300 mois), on aura tout payé:\n$$ (847.71 - \\frac{0.02}{12}\\cdot 200000) \\frac{\\left(\\frac{0.02}{12}+1\\right)^{300}-1}{\\frac{0.02}{12}} = 200000.51 $$\nL\u0026rsquo;écart de 0.51$ ici s\u0026rsquo;explique par les chiffres que j\u0026rsquo;ai arrondis pour l\u0026rsquo;écriture. En gardant une plus grande précision sur le nombre de chiffres après la virgule, on arriverait évidemment à \\(H_0 = 200000\\). Faites le test!\nMaintenant qu\u0026rsquo;on a le montant de prêt hypothécaire payé, on aimerait aussi avoir la somme d\u0026rsquo;intérêt payé!\nPortion d\u0026rsquo;intérêt du paiement bancaire Le plus gros est déjà fait!!! En effet, comme j\u0026rsquo;ai dit au départ,\n$$ P = y_k + x_k,\\quad \\text{pour tout}\\ k $$\nCe faisant, comme on connait \\(P\\) et \\(x_k\\), on a donc aussi \\(y_k = P - x_k\\). Notons la somme d\u0026rsquo;intérêt payée au bout de \\(m\\) mois \\(Y_m\\). Il s\u0026rsquo;en suit que:\n$$ \\begin{align} Y_m = \\sum_{k=1}^m y_k \u0026amp;= \\sum_{k=1}^m \\left(P - x_k\\right)\\\\\n\u0026amp;= \\sum_{k=1}^m P - \\sum_{k=1}^m x_k\\\\\n\u0026amp;= mP - \\sum_{k=1}^m x_k\\\\\n\\end{align} $$\nFinalement, comme on connaît l\u0026rsquo;expression de la somme sur \\(x_k\\), c.-à-d. \\(X_m\\), on écrit:\n$$ Y_m = mP - (P - \\iota{}H_0) \\frac{(\\iota{}+1)^m - 1}{\\iota{}} $$\nExemple\nSelon les hypothèses faites plus haut:\n$$ \\begin{cases} H_0 \u0026amp;= 200000 \\\\\ni \u0026amp;= 0.02 \\\\\nP \u0026amp;= 847.71 \\end{cases} $$\nle lecteur est invité à calculer la somme d\u0026rsquo;intérêt payée après 5 ans, c\u0026rsquo;est-à-dire calculer \\(Y_5\\).\nRappel: l\u0026rsquo;intérêt par mois est donné par \\(\\iota{} = \\frac{i}{12}\\).\nConclusion Ces calculs sont déterminants dans l\u0026rsquo;examen de l\u0026rsquo;avantage à acheter une propriété. Cependant, ces chiffres ne sont pas suffisants puisqu\u0026rsquo;il faut aussi considérer les frais qui s\u0026rsquo;ajoutent à l\u0026rsquo;habitation comme j\u0026rsquo;ai mentionné plus haut dans l\u0026rsquo;article. Bien sûr d\u0026rsquo;autres facteurs jouent comme la mise de fond initiale disponible, les frais ponctuels à l\u0026rsquo;achat (notaire, droits de mutation, etc.), le coût d\u0026rsquo;un courtier lors de la vente de la propriété ainsi que l\u0026rsquo;augmentation potentielle moyenne de la valeur de la propriété. En effet, afin de calculer l\u0026rsquo;avantage d\u0026rsquo;un achat, il est primordial de calculer les frais de vente puisqu\u0026rsquo;une habitation constitue un actif considérable qui pèse dans la balance. Certains scénarios peuvent présenter des profits de plusieurs milliers de dollars lors d\u0026rsquo;une vente qu\u0026rsquo;après 5 ans de possession. Par ailleurs, l\u0026rsquo;acquisition d\u0026rsquo;une propriété amène aussi la capacité de louer le lieu d\u0026rsquo;habitation, ce qui offre en soi une dimension de flexibilité.\n","description":"","id":9,"section":"maths","tags":["Hypothèque","Prêt","Dette","Intérêt","Paiement bancaire","Newton","Pascal"],"title":"Calculs hypothécaires","uri":"https://sim590.github.io/fr/maths/calculs-hypothecaires/"},{"content":"Debian est une des distributions de GNU/Linux les plus communes et robustes grâce à son système de publication de version structuré et méticuleux. Les versions passent par différents stades de développement appelés «branches». On peut voir ces branches comme des «versions» de Debian qui ne sont pas figées dans le temps contrairement aux publications de Debian. Par exemple, Buster est le nom de la dernière version publiée par Debian à ce jour et la branche correspondant à Debian est appelée stable. Par défaut, il s\u0026rsquo;agit de la branche avec laquelle Debian s\u0026rsquo;installe. Comme le système de paquetage inclut d\u0026rsquo;abord les paquets dans la branche unstable, puis testing et finalement stable, les versions prennent un certains temps à aboutir. Ce faisant, ceci garantie une stabilité aux utilisateurs (d\u0026rsquo;où le nom de la branche). Ceci dit, certains utilisateurs plus avancés ayant le désir d\u0026rsquo;un système plus à jour peuvent configurer leur système afin que celui-ci passe à testing. Ce processus est très commun parmi les utilisateurs avancés et comporte pratiquement très peu d\u0026rsquo;inconvénients. Pour plus d\u0026rsquo;information par rapport aux branches, voyez les différents liens ci-après:\nhttps://www.debian.org/releases/\nhttps://www.debian.org/doc/manuals/debian-faq/debian-faq.fr.pdf (PDF)\nPersonnellement, je vois testing comme un bon compromis entre la fine pointe et la robustesse du logiciel. Dans ce qui suit, je vous montre comment passer à testing ainsi que comment adéquatement configurer apt pour garantir un fin contrôle sur la source des paquets que vous téléchargez des branches testing, unstable et experimental.\nN.B: Je fais l\u0026rsquo;hypothèse que le lecteur se trouve sur Debian dans la branche stable et que les fichiers de configuration qui se trouvent sur votre système sont par défaut.\nN.B no. 2: Le lecteur doit être avisé que les étapes de mise à jour que nous effectuerons ne sont pas réversibles. Une fois passé à testing, on ne revient pas dans stable. Si c\u0026rsquo;est absolument nécessaire, on doit alors réinstaller le système. Si votre système possède une partition /home il est assez aisé de réinstaller sans avoir à copier les données de votre répertoire utilisateur. Ceci dit, il est toujours pertinent de faire une sauvegarde, le cas échéant. Bien sûr, ce n\u0026rsquo;est pas nécessaire pour simplement passer à testing.\n/etc/apt/sources.list.d Passer à une version subséquente de Debian consiste à installer les versions plus à jour des paquets du système. Pour ce faire, on doit donc configurer la source où on prendra ces paquets. Il faut donc déplacer (ou supprimer) le fichier de configuration actuel là où il ne sera pas effectif.\n1  rm /etc/apt/sources.list   ### Mise en garde ###  Je fais l\u0026rsquo;hypothèse que les fichiers de configuration sont par défaut, c.-à-d. que vous n\u0026rsquo;avez pas de fichier ajoutés autre comme par exemple certains fichiers créés après l\u0026rsquo;exécution d\u0026rsquo;instructions d\u0026rsquo;installation pour des logiciels externes aux serveurs Debian (pour Google Chrome par exemple). Ce faisant, si certains fichiers de ce genre sont présents où que vous avez des sources supplémentaires nécessaire pour votre système, veillez à les préserver.\nSi le fichier précédent ne se trouvait pas à cet endroit au premier abord, vous avez possiblement une configuration divisée en plusieurs fichiers de la forme /etc/apt/sources.list.d/*.list. Si c\u0026rsquo;est le cas, veilliez à les retirer (ou déplacer hors de /etc/apt/sources.list.d/).\nMaintenant, il faut s\u0026rsquo;assure que le répertoire /etc/apt/sources.list.d/ existe.\n1  mkdir -p /etc/apt/sources.list.d   Ensuite, il suffit de créer le fichier /etc/apt/sources.list.d/testing.list contenant les sources de la branche testing:\n1 2  deb http://ftp.ca.debian.org/debian/ testing main contrib non-free deb-src http://ftp.ca.debian.org/debian/ testing main contrib non-free   Personnellement, j\u0026rsquo;inclus non-free car certains paquets qui s\u0026rsquo;y trouvent peuvent être utiles, mais je dois avouer que le dernier paquet que j\u0026rsquo;ai utilisé provenant de cette section browser-plugin-freshplayer-pepperflash et les pages Flash ne courrent vraiment plus les rues de nos jours. Bref, ça ne fait pas de mal de l\u0026rsquo;inclure.\nMaintenant, il s\u0026rsquo;agit de passer à la nouvelle version. Premièrement, on met la liste des sources à jour:\n1  apt update   Ensuite, on peut mettre à jour les paquets comme tel:\n1  apt upgrade   Finalement, pour permettre à apt de mettre à jour certains paquets impliquant la suppression d\u0026rsquo;autres paquets ou l\u0026rsquo;installation de nouveaux paquets (ce que upgrade ne fait pas par défaut), on doit faire:\n1  apt dist-upgrade   Et voilà ! Vous êtes maintenant sur testing.\nÀ la fine pointe! Un accès à unstable et experimental permet à l\u0026rsquo;utilisateur aisé de mettre la main sur des paquets encore plus à jour. Ceci dit, le téléchargement n\u0026rsquo;est pas toujours possible et peut engendrer des cassures de dépendance, donc c\u0026rsquo;est à faire à vos propres risques et périls.\nPremièrement, on crée les fichiers /etc/apt/sources.list.d/unstable.list:\n1  deb http://ftp.ca.debian.org/debian/ unstable main contrib non-free   et /etc/apt/sources.list.d/experimental.list:\n1  deb http://ftp.ca.debian.org/debian/ experimental main contrib non-free   Très bien, mais ce n\u0026rsquo;est pas tout!\nIci, il est primordial d\u0026rsquo;apparier cette configuration à un triplet de fichiers qui dictera l\u0026rsquo;ordre de priorité des sources. En effet, tel que configuré jusqu\u0026rsquo;ici, toutes les sources seraient en concurrence et la version la plus à jour pour tous les paquets serait installée, c\u0026rsquo;est-à-dire que tous les paquets (ou presque) passeraient à la version experimental ou unstable suivant une mise à jour avec apt update \u0026amp;\u0026amp; apt upgrade et ce n\u0026rsquo;est pas ce qu\u0026rsquo;on veut! Afin de palier à ce problème, on assure premièrement la création du répertoire des préférences:\n1  mkdir -p /etc/apt/preferences.d   Maintenant, les 3 fichiers ci-après doivent être créés:\n  /etc/apt/preferences.d/testing\n1 2 3  Package: * Pin: release a=testing Pin-Priority: 900     /etc/apt/preferences.d/unstable\n1 2 3  Package: * Pin: release a=unstable Pin-Priority: 800     /etc/apt/preferences.d/experimental\n1 2 3  Package: * Pin: release a=experimental Pin-Priority: 700     Les champs Package, Pin et Pin-Priority indiquent respectivement les paquets, la branche de ceux-ci et l\u0026rsquo;indice de priorité. Plus le nombre est élevé et plus la branche a priorité. Ce faisant, le lecteur comprend bien que testing est configuré comme la branche principale. Les autres branches sont accessibles, mais ne seront utilisées que si les paquets installés ne sont pas disponibles dans la/les branche(s) avec la plus grande priorité.\nAfin que les changements soient effectifs, il est nécessaire de rouler\n1  apt update   Le tout permet donc finalement d\u0026rsquo;installer des paquets depuis unstable simplement en passant l\u0026rsquo;option -t à apt. Par exemple, afin d\u0026rsquo;installer la version de vim depuis unstable, il suffit d\u0026rsquo;exécuter:\n1  apt install -t unstable vim   ","description":"","id":10,"section":"debian","tags":["GNU/Linux","Aptitude","Paquet Debian","Branche Debian"],"title":"Debian: passer à «testing»","uri":"https://sim590.github.io/fr/debian/passer-%C3%A0-testing/"},{"content":"fzf est un programme filtrant le flux de son entrée standard par mots clefs fournis par l\u0026rsquo;utilisateur de manière interactive. Le filtre est du type fuzzy (d\u0026rsquo;où le nom fzf pour fuzzy finder), c\u0026rsquo;est-à-dire que les termes fournis au programme sont décomposés en sous-mots afin de permettre des recherches approximatives par l\u0026rsquo;utilisateur. Par exemple, prenons l\u0026rsquo;entrée suivante:\n1 2 3  toto titi tutu   Si l\u0026rsquo;utilisateur fournissait le terme tt, toutes les lignes seraient sélectionnées, puisque les sous-mots t et t se trouvent tous deux dans toutes les lignes. Cependant, avec le terme de recherche oo, seul la première ligne correspondrait avec le mot toto selon le même raisonnement.\nN.B: Les configurations que j\u0026rsquo;ai listées dans cet article ont été téléversées et sont disponibles pour consultation dans mon dépôt de fichiers de configurations.\nLes principales fonctionnalités Utilisation de base Comme mentionné précédemment, fzf agit sur son entrée standard. Ainsi, on l\u0026rsquo;utilise comme suit:\n1  find . | fzf   Ceci donne donc toute la liste des fichiers dans le répertoire courant (et tous ceux qui se trouvent sous celui-ci) et fzf démarre en permttant à l\u0026rsquo;utilisateur de spécifier des mots-clefs:\nDans l\u0026rsquo;exemple de la figure ci-haut, si on ajoute le terme Documents, fzf filtrera les lignes afin de n\u0026rsquo;afficher que celles qui contiennent ce mot. Les résultats les plus hauts dans la liste (selon la sortie de find) sont préservés au haut de la liste après le filtre:\nOn succède les termes en les séparant (ou non) par des espaces:\nCeci permet donc de filtrer une liste de fichiers afin de tomber très rapidement sur les résultats qu\u0026rsquo;on souhaite. En ajoutant des espaces, on peut spécifier des options à l\u0026rsquo;aide de caractères spéciaux (!, $ et ' par exemple). Le caractère $ indique que le mot qui le précède (délimité par des espaces) se trouve à la fin de la ligne (ceci peut sonner familier aux connaisseurs des expressions régulières). L\u0026rsquo;utilisation de l\u0026rsquo;apostrophe ' au début du mot, permet de ne sélectionner que les lignes contenant le mot tel quel (donc pas de décomposition en sous-mots pour ce mot en particulier).\nAfin de sélectionner un choix, l\u0026rsquo;utilisateur utilise ctrl-j pour descendre et ctrl-k pour monter. Une fois la ligne sélectionnée avec le curseur, il suffit d\u0026rsquo;appuyer sur la touche ENTRÉE afin de confirmer le choix.\nLorsque le choix est fait, fzf affiche la ligne sélectionnée à la sortie standard.\nExemple Un exemple typique d\u0026rsquo;utilisation est celui d\u0026rsquo;ouvrir un fichier avec son éditeur de texte préféré:\n1  vim $(fzf)   Filtre par défaut Comme l\u0026rsquo;utilisation première de fzf est de lister les fichiers, il est possible de simplement appeler fzf tout court sans l\u0026rsquo;aide de find pour obtenir le même résultat.\n1  fzf   En particulier, le comportement par défaut peut être réglé par la variable d\u0026rsquo;environnement FZF_DEFAULT_COMMAND. Personnellement, j\u0026rsquo;utilise la configuration:\n1  export FZF_DEFAULT_COMMAND=\u0026#34;find .\u0026#34;   Peu importe l\u0026rsquo;outil d\u0026rsquo;interface système (IS) que vous utilisez, il suffit d\u0026rsquo;utiliser l\u0026rsquo;instruction adéquate permettant la configuration de la variable d\u0026rsquo;environnement. Personnellement, comme mon gestionnaire de bureau est gdm, je configure cette instruction dans ~/.profile. À vrai dire, j\u0026rsquo;utilise un fichier séparé (nommé ~/.fzf_env) qui est chargé par le fichier ~/.profile à l\u0026rsquo;aide de l\u0026rsquo;instruction source:\n1 2 3 4  source ~/.fzf_env # Contient le contenu listé précédemment. export FZF_DEFAULT_COMMAND # Nécessaire afin de bien exposer la variable après # l\u0026#39;avoir configuré dans ~/.fzf_env   Choix multiples Il arrive qu\u0026rsquo;on utilise des programmes permettant de lister plusieurs fichiers sur une même ligne de commande. Heureusement, fzf admet l\u0026rsquo;option --multi et permet donc de sélectionner plusieurs choix. Entre autres, pour sélectionner plusieurs fichiers à ouvrir dans Vim, on peut écrire:\n1  vim $(fzf -m)   L\u0026rsquo;utilisateur peut alors sélectionner les choix multiples à l\u0026rsquo;aide de la touche TAB.\nFonctionnalités de l\u0026rsquo;interface système Deux fonctionnalités principales sont fournies: des touches raccourcis ainsi que des scripts de complétion.\nComplétion N.B: l\u0026rsquo;utilisateur doit lui-même installer les scripts de complétion. Il suffit simplement d\u0026rsquo;include une instruction source du scripts de complétion dans sa configuration personnelle.\nLa complétion de la ligne de commande s\u0026rsquo;effectue pour toute commande à l\u0026rsquo;aide de la chaîne de caractères dédiée **. Lorsque cette chaîne est reconnue par les scripts de complétion (voir les procédures d\u0026rsquo;installation), les chemins sont complétés à la ligne de commande et les choix ajoutés à celle-ci. Par exmeple, si on souhaite se déplacer avec cd dans un répertoire très profond, on écrit:\n1  cd **   suivi de la touche TAB et fzf se lance et permet de choisir le répertoire. Une fois sélectionné, la ligne de commande de l\u0026rsquo;utilisateur sera changée par cd suivi de son choix. Par exemple:\n1  cd un/très/long/chemin/vers/le/répertoire/que/je/cherchais   Ce mode d\u0026rsquo;exécution permet donc de facilement modifier la ligne de commande avant d\u0026rsquo;exécuter celle-ci au besoin. Dans le cas de cd, seuls les répertoires seront listés par fzf. Sinon, avec Vim par exemple, en écrivant vim ** et en appuyant ensuite sur TAB, fzf affichera les fichiers et les répertoires.\nDeux cas particuliers et intéressants sont aussi fournis. Il s\u0026rsquo;agit de ceux de ssh et kill. Pour ssh, en écrivant ssh **, la liste des noms d\u0026rsquo;hôtes connus (configurés dans /etc/hosts) sera fournis en complétion.\nComme il est normalement possible de se connecter à un hôte en fournissant son adresse BONJOUR (au format nom-d-hôte.local), il serait pertinent de fournir la liste des noms d\u0026rsquo;hôtes sur le réseau local. Cependant, fzf ne le fait pas. Ceci dit, il est trivial de surcharger la fonction de complétion relative à ssh. Voir la section à ce sujet.\nMaintenant, le cas de kill. Cette fonction est une des plus attrayantes. Il suffit d\u0026rsquo;écrire kill suivi d\u0026rsquo;un espace et appuyer sur TAB (sans ** cette fois-ci). La liste des processus est affichée avec les lignes de commande exactes utilisées pour lancer chacun de ceux-ci. On peut donc rechercher parmi chacun d\u0026rsquo;eux et même en sélectionner plusieurs. Le résultat sera que chacun des identifiants de processus seront ajoutés à la ligne de commande afin que l\u0026rsquo;utilisateur puisse tuer tous les processus d\u0026rsquo;un trait.\nPar exemple, suivant la capture ci-haut où les mots clefs urxvt et vim ont été fourni, on peut sélectionner certains processus à tuer. Le résultat sera la ligne de commande suivante:\n1  kill 17292 17279 27346   Touches raccourcis pour l\u0026rsquo;IS ALT+C En plus d\u0026rsquo;accélérer grandement le déplacement de l\u0026rsquo;utilisateur dans le système par la ligne de commande, fzf va un cran plus loin en fournissant la touche ALT+C (pour Bash et Zsh). Encore mieux: fzf fourni la possibilité de configurer une fenêtre d\u0026rsquo;affichage qui donne un aperçu du répertoire devant le curseur en temps réel:\nLa simple sélection du répertoire enclanche toute suite le changement de répertoire une fois la touche ENTRÉE appuyée. Afin d\u0026rsquo;obtenir cette belle fenêtre d\u0026rsquo;affichage, l\u0026rsquo;utilisateur doit spécifier la commande à utiliser:\n1  export FZF_ALT_C_OPTS=\u0026#34;--preview \u0026#39;tree -C {} | head -200\u0026#39;\u0026#34;   CTRL+R Comme la version de moi des jours précédants ma découverte de fzf, vous utilisez possiblement CTRL+R pour rechercher les commandes précédemment entrées afin d\u0026rsquo;éviter de les réécrire. Cela ressemble normalement à quelque chose comme ceci:\nMalheureusement, pas beaucoup d\u0026rsquo;information est affiché et il n\u0026rsquo;est pas possible de renchérir sur la recherche de manière très aisée et efficace. Fzf fournit un remplacement pour cela et change complètement l\u0026rsquo;expérience.\nFinalement\u0026hellip; Pour plus de détails, voir la documentation de fzf à l\u0026rsquo;adresse suivante:\nhttps://github.com/junegunn/fzf\nLa page Wiki est aussi une bonne ressource:\nhttps://github.com/junegunn/fzf/wiki\nExtension de la complétion Exemple trivial Afin de fournir la complétion pour le programme toto, il suffit d\u0026rsquo;écrire une instruction comme celle-ci:\n1 2 3 4 5 6 7 8 9  _fzf_complete_toto() { _fzf_complete \u0026#39;\u0026#39; -- \u0026#34;$@\u0026#34; \u0026lt; \u0026lt;( echo tutu echo titi echo tata # On peut mettre toutes les instructions zsh qu\u0026#39;on veut ici afin de # bâtir la liste passée à fzf. ) )   N.B: Il est spécifié sur la page de documentation de Fzf que l\u0026rsquo;IPA est instable et change de version en version. En particulier, cela concerne la fonction _fzf_complete. Par exemple, la version du paquet Debian que j\u0026rsquo;utilise est telle que la fonction _fzf_complete ne reconnaît pas l\u0026rsquo;argument dédié --. Il faut donc simplement le retirer.\nssh et les adresses \u0026ldquo;*.local\u0026rdquo; Comme mentionné plus tôt, la complétion par les scripts de fzf pour ssh ne fournissent pas les noms d\u0026rsquo;hôtes dans le réseau local, ce qui pourrait s\u0026rsquo;avérer souvent utile. Afin de remédier à cela, il suffit d\u0026rsquo;inclure le bout de code suivant dans sa configuration:\n1 2 3 4 5 6 7 8 9 10 11  # Dans le fichier: ~/.zshrc _fzf_complete_ssh() { _fzf_complete +m -- \u0026#34;$@\u0026#34; \u0026lt; \u0026lt;( setopt localoptions nonomatch command cat \u0026lt;(cat ~/.ssh/config ~/.ssh/config.d/* /etc/ssh/ssh_config 2\u0026gt; /dev/null | command grep -i \u0026#39;^\\s*host\\(name\\)\\? \u0026#39; | awk \u0026#39;{for (i = 2; i \u0026lt;= NF; i++) print $1 \u0026#34; \u0026#34; $i}\u0026#39; | command grep -v \u0026#39;[*?]\u0026#39;) \\  \u0026lt;(command grep -oE \u0026#39;^[[a-z0-9.,:-]+\u0026#39; ~/.ssh/known_hosts | tr \u0026#39;,\u0026#39; \u0026#39;\\n\u0026#39; | tr -d \u0026#39;[\u0026#39; | awk \u0026#39;{ print $1 \u0026#34; \u0026#34; $1 }\u0026#39;) \\  \u0026lt;(command grep -v \u0026#39;^\\s*\\(#\\|$\\)\u0026#39; /etc/hosts | command grep -Fv \u0026#39;0.0.0.0\u0026#39;) | awk \u0026#39;{if (length($2) \u0026gt; 0) {print $2}}\u0026#39; | sort -u command avahi-browse -atlr | grep -o \u0026#39;\\\u0026lt;\\S\\+\\.local\u0026#39; | sort -u ) }   Il s\u0026rsquo;agit du code exacte repris du script de complétion fourni par fzf avec la dernière ligne ajoutée permettant de lister les noms d\u0026rsquo;hôte.\n1  command avahi-browse -atlr | grep -o \u0026#39;\\\u0026lt;\\S\\+\\.local\u0026#39; | sort -u   Ainsi, les noms d\u0026rsquo;hôtes présents dans le réseau local s\u0026rsquo;afficheront.\nAptitude Le gestionnaire de paquets de Debian est l\u0026rsquo;exemple parfait où fzf devient très utile. Il est courrant de chercher un paquet sans connaître les mots clefs exacts à utiliser. Une vue d\u0026rsquo;ensemble interractive de recherche facilite énormément ce processus.\nIl suffit d\u0026rsquo;écrire apt commande ** où commande est une commande valide d'apt qui demande des noms de paquets en argument. Par la suite, on tape sur la touche TAB et la magie se lance. La recherche s\u0026rsquo;effectuera sur la liste de paquets jointe à leur description correspondante. Pour l\u0026rsquo;instant, la configuration prend en charge les commandes install, show, search, remove, reinstall et purge. Rien ne vous empêche de vous inspirer du code pour ajouter des commandes. De plus, comme la configuration est en mode multi-choix, (fzf se fait passer le drapeau -m), on peut choisir plusieurs noms de paquets avec TAB et les touches pour monter et descendre le curseur (ctrl-k, ctrl-j).\nLe code que j\u0026rsquo;ai écrit pour rendre cela possible est inspiré du bout de code trouvé ici.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  list_aptitude_packages() { if [[ $@ =~ \u0026#39;apt install\u0026#39;* ]] \\  || [[ $@ =~ \u0026#39;apt show\u0026#39;* ]] \\  || [[ $@ =~ \u0026#39;apt search\u0026#39;* ]]; then command apt list --verbose elif [[ $@ =~ \u0026#39;apt remove\u0026#39;* ]] \\  || [[ $@ =~ \u0026#39;apt reinstall\u0026#39;* ]] \\  || [[ $@ =~ \u0026#39;apt purge\u0026#39;* ]] ; then command apt list --verbose --installed fi } _fzf_complete_apt() { IFS=\u0026#39; \u0026#39; read -A ARGS \u0026lt;\u0026lt;\u0026lt; $@ prg=\u0026#34;${ARGS[1]}\u0026#34; setopt extendedglob if [[ \u0026#34;$prg\u0026#34; =~ \u0026#34;apt\u0026#34; ]]; then if [[ $@ =~ \u0026#39;apt install\u0026#39;* ]] \\  || [[ $@ =~ \u0026#39;apt show\u0026#39;* ]] \\  || [[ $@ =~ \u0026#39;apt search\u0026#39;* ]] \\  || [[ $@ =~ \u0026#39;apt remove\u0026#39;* ]] \\  || [[ $@ =~ \u0026#39;apt reinstall\u0026#39;* ]] \\  || [[ $@ =~ \u0026#39;apt purge\u0026#39;* ]] ; then _fzf_complete \u0026#39;--multi\u0026#39; \u0026#34;$@\u0026#34; \u0026lt; \u0026lt;( list_aptitude_packages $ARGS 2\u0026gt;/dev/null | \\  command tail --lines +2 | \\  command sed \u0026#39;/^ *$/d\u0026#39; | \\  command sed \u0026#39;N;s/\\n */^/;p\u0026#39; | \\  command column -t -s \u0026#39;^\u0026#39; ) fi fi } _fzf_complete_apt_post() { cut --delimiter \u0026#39;/\u0026#39; --fields 1 | \\  xargs --max-args 1 --no-run-if-empty printf \u0026#34;%q \u0026#34; }   Remarque: Cette configuration ne fonctionne que pour apt et pas pour apt-cache, apt-get, etc. Ce n\u0026rsquo;est pas bien grave puisque la commande apt vise à réduire le nombre de commandes différentes à utiliser de toute manière en centralisant tout sous une seule. Ceci dit, le code serait plus intéressant s\u0026rsquo;il prenait en charge les autres programmes. Je ferai possiblement une mise à jour pour prendre en charge ces cas.\npass (passwordstore) https://passwordstore.org\nCet outil qui permet la gestion des mots de passe pour l\u0026rsquo;utilisateur de l\u0026rsquo;IS possède déjà des fonctions de recherche (pass grep et pass find), mais celles-ci n\u0026rsquo;arrivent pas à la hauteur de fzf. La liste de courriel de pass comporte un échange dans lequel on retrouve un échantillon de configuration permettant de compléter les requêtes à pass avec zsh (la même fonction peut être utilisée pour Bash, voir la documentation).\n1 2 3 4 5 6  _fzf_complete_pass() { ARGS=\u0026#34;$@\u0026#34; _fzf_complete \u0026#39;\u0026#39; \u0026#34;$@\u0026#34; \u0026lt; \u0026lt;( command find ~/.password-store/ -name \u0026#34;*.gpg\u0026#34; | sed -r \u0026#39;s,(.*)\\.password-store/(.*)\\.gpg,\\2,\u0026#39; ) }   N.B: une erreur s\u0026rsquo;était glissée dans la version originale. J\u0026rsquo;ai pris soin de la corriger dans l\u0026rsquo;échantillon de configuration ci-haut.\nOn peut ainsi accéder à ses mots de passe bien plus facilement!\nComme pour les exemples précédents, on entre la touche TAB après les deux étoiles et le menu ci-haut apparaît. On sélectionne et la ligne de commande est complétée. Par exemple, en sélectionnant le premier élément, on obtiendrait la ligne de commande résultante:\n1  pass personnel/access-point/tp-link   Ceci est très utile lorsqu\u0026rsquo;on ne se souvient plus exactement du nom du fichier contenant le mot de passe qu\u0026rsquo;on recherche.\nRanger Ranger est un gestionnaire de fichiers en mode texte très versatile. Par sa simplicité de conception, il permet à ses développeurs de se concentrer à rendre possible de multiples fonctions en tirant avantage entre autres de l\u0026rsquo;IS.\nBien qu\u0026rsquo;il permette le déplacement entre les répertoires de manière assez rapide, fzf peut l\u0026rsquo;aider à faire mieux! Il existe un greffon permettant de sélectionner un répertoire (ou un fichier) pour y déplacer le curseur. Il suffit de placer le fichier python du greffon sous ~/.config/ranger/plugins/fzf.py et on peut directement appeler la fonction en appelant la commande :fzf. Il peut être commode de configurer une touche dans ~/.config/ranger/rc.conf pour un maximum de vitesse d\u0026rsquo;exécution.\nGreffon pour Vim Bien sûr, il existe un greffon super puissant pour Vim. Je n\u0026rsquo;en donnerai pas de détail ici. Ce sera pour un autre article possiblement. Je donne tout de même le lien vers le greffon:\nhttps://github.com/junegunn/fzf.vim\nComplétion avec sudo Malheureusement, ce n\u0026rsquo;est pas possible pour le moment de faire fonctionner la complétion avec sudo sur la ligne de commande. C\u0026rsquo;est un peu fâcheux puisque le comportement usuel des fonctions de complétion pour ZSH prend normalement ce détail en charge.\nVoir https://github.com/junegunn/fzf/issues/1981 pour rester au fait de ce problème.\nEn conclusion Il est pertinent de noter comment que fzf remplit parfaitement les critères d\u0026rsquo;un programme de style UNIX. En effet, il répond adéquatement aux attentes comme quoi il fait une et une seule chose, mais le fait bien. Il est impératif de remarquer que cette qualité additionnée avec l\u0026rsquo;IS de conception UNIX permet l\u0026rsquo;augmentation de tous les autres programmes communiquant par cette même interface système. Fzf exprime très bien l\u0026rsquo;harmonie que rend possible entre les différents programme un système comme GNU/Linux. En somme, ce programme augmente considérablement la rapidité d\u0026rsquo;exécution des tâches à la ligne de commande par l\u0026rsquo;utilisateur. C\u0026rsquo;est pourquoi je recommande à tous les curieux de prendre le temps de jouer avec et de l\u0026rsquo;adopter.\nJe remercie Jaël Gareau pour m\u0026rsquo;avoir fait part de cette découverte.\n","description":"","id":11,"section":"outils","tags":["GNU/Linux","Productivité","Vim","zsh","ranger","pass"],"title":"fzf: comment optimiser son utilisation de la ligne de commande","uri":"https://sim590.github.io/fr/outils/fzf/"},{"content":"Vim est un éditeur de texte et clairement le meilleur qui soit. Je ne dis pas ça sans peser mes mots. Ceci dit, il ne faut pas lui prêter une identité qu\u0026rsquo;il n\u0026rsquo;a pas. Vim n\u0026rsquo;est pas un environnement de développement intégré (EDI ou IDE en anglais) complet. Cependant, plusieurs aspects à son utilisation font sa grande force pour fournir un EDI complet à son usager:\n un langage de touches permettant aux doigts de faire tout le travail d\u0026rsquo;édition de texte (couper, effacer, coller, réordonner, formater, etc.). En effet, dans une boîte de texte régulière (comme ce qu\u0026rsquo;on trouve dans les EDIs populaires) la modification de texte, et non la simple écriture, n\u0026rsquo;est pas chose facile. Elle demande souvent l\u0026rsquo;utilisation de la souris, donc la perte de la position des mains déjà en place pour écrire. De plus, cette approche est normalement très lente. Avec Vim, les doigts font le travail. La meilleure comparaison pour comprendre le sentiment est justement celle de l\u0026rsquo;écriture. On ne pense pas à trouver les touches pour écrire et cela se fait automatiquement. Pour la modification de texte avec Vim, c\u0026rsquo;est la même chose. un langage de script (VimScript) qui lui permet une haute extensibilité; une intégration de l\u0026rsquo;interface système (IS ou le shell en anglais). L\u0026rsquo;utilisation de l\u0026rsquo;IS est entièrement intégrée à travers VimScript ainsi que les différents modes de Vim (Normal, Visual, CMD, etc.). Je ne peux mettre assez l\u0026rsquo;accent sur comment ce trait de Vim est si significatif. Ce faisant, de manière totalement gratuite, un utilisateur de Vim bénéficie déjà des fonctionnalités de l\u0026rsquo;IS dans son éditeur de texte sans avoir recours à l\u0026rsquo;installation très particulière d\u0026rsquo;extension par son EDI. On dit souvent que l\u0026rsquo;IS constitue en réalité l\u0026rsquo;environnement de développement d\u0026rsquo;un utilisateur de Vim. une capacité d\u0026rsquo;intégrer des greffons (plugins en anglais); et une communauté de développeurs très investie dans le partage de code et d\u0026rsquo;outils qui rendent l\u0026rsquo;intégration d\u0026rsquo;outils de développement aisée et facilement personnalisable.  Le tout fait de Vim le choix idéal. Dans ce qui suit, je prends le temps de développer concrètement mon point de vue en m\u0026rsquo;attardant à des préoccupations très importantes de tout développeur, mais selon ma perspective, bien entendu. Je compte donc explorer le mode Normal de Vim, l\u0026rsquo;intégration avec l\u0026rsquo;IS plus en détail, l\u0026rsquo;intégration de GDB (depuis Vim 8) et les différents greffons permettant une sensation d\u0026rsquo;EDI complet.\nN.B: Cet article ne vise pas à vous apprendre les bases de Vim, mais vraiment à convaincre sur le fait qu\u0026rsquo;il constitue un incontournable pour tout développeur.\nLangage de touches Vim comporte plusieurs modes:\n Normal; Insertion (équivalent à une boîte de texte usuelle); Visuel; Visuel en bloc; Ligne de commande (pas de l\u0026rsquo;IS, mais bien de Vim); \u0026hellip;  Le langage de touche est le celui du mode Normal. C\u0026rsquo;est là que s\u0026rsquo;opère la magie des doigts permettant l\u0026rsquo;édition aisée du texte. Je ne ferai pas un cours complet sur ce mode, mais je vous invite à lire plus amplement sur le sujet. Pour ce faire, référez-vous à la liste de références au bas de cet article.\nAinsi, dans le mode Normal, les touches de l\u0026rsquo;alphabet n\u0026rsquo;insèrent pas simplement les lettres correspondantes, mais exécutent des fonctions élémentaires de Vim. On peut catégoriser ces fonctions en trois (3) types:\n un mouvement: la touche déplace le curseur. une modification: la touche supprime, déplace, coupe ou colle du texte. des fonctions variées\u0026hellip;  Mouvements Afin de se déplacer dans le fichier, on utilise tout le temps le mode normal puisque celui-ci comporte des fonctions très efficaces à cette fin. Voici quelques unes de celles-ci:\n h: déplace le curseur à gauche d\u0026rsquo;une case; j: déplace le curseur sur la ligne inférieure; k: déplace le curseur sur la ligne supérieure; l: déplace le curseur à droite d\u0026rsquo;une case.  Oui, c\u0026rsquo;est bien la raison derrière l\u0026rsquo;icône du poing hjkl comme logo de mon blog. C\u0026rsquo;est en quelque sorte la signature de Vim.\nComme on peut le voir, ces touches remplacent complètement les flèches du clavier. Il y a une raison très pertinente pour motiver l\u0026rsquo;utilisation de ces touches plutôt que les flèches: les mains restent en place là où elles ont besoin d\u0026rsquo;être afin d\u0026rsquo;utiliser toutes les fonctionnalités de Vim. Voici encore d\u0026rsquo;autres touches de mouvement utiles:\n w: avance le curseur jusqu\u0026rsquo;au début du prochain mot; e: avance le curseur jusqu\u0026rsquo;à la fin du prochain mot; b: recule le curseur jusqu\u0026rsquo;au début du dernier mot; ge: recule le curseur jusqu\u0026rsquo;à la fin du dernier mot.  Tous ces mouvements ont leur équivalent pour des gros mots (un mot séparé par des espaces blancs). Il y a donc les touches W, E, B et gE qui exécutent les fonctions correspondantes.\nLa touche f est une touche capitale. Elle est utilisée conjointement avec ; et , afin de naviguer sur les différentes occurrences d\u0026rsquo;une même lettre. On utilise la touche f, qui attend un argument, afin de trouver la prochaine occurrence d\u0026rsquo;une lettre. Dans l\u0026rsquo;exemple ci-haut, f/ déplace le curseur jusqu\u0026rsquo;à la prochaine occurrence de / sur la ligne. Et si on souhaitait plutôt aller à la seconde ou la troisième occurrence? Eh bien, il suffit de taper la touche ; et le curseur ira à la prochaine occurence. Cette procédure se répète indéfiniment. Si on connait le rang du caractère qu\u0026rsquo;on cherche, disons 4, alors on peut simplement faire 4f/.\nRemarque: Plusieurs commandes prennent des compteurs en préfixe. Par exemple, pour avancer de 10 mots, on pourrait faire 10w.\nBien sûr, il y a plusieurs autres touches de mouvements utiles, mais encore une fois cet article n\u0026rsquo;est pas un tutoriel en soi. Pour une liste exhaustive, référez-vous aux références plus bas. Poursuivons avec les touches de modification du texte.\nModification du texte Ci-après, quelques fonctions de modification de texte qui reviennent souvent:\n d: fonction de suppression. Attend un argument de mouvement; c: fonction de changement (suppression et propulsion dans le mode Insertion). Attend un argument de mouvement; y: copie du texte. Attend un argument de mouvement; p: colle du texte.  Ainsi, on compose les fonctions de mouvement avec les fonctions de modification afin de modifier le texte.\nPar exemple, afin de changer l\u0026rsquo;intérieur d\u0026rsquo;une parenthèse dans une ligne de code comme dans l\u0026rsquo;exemple ci-haut, on procède en tapant sur les touches ci). La touche c est la commande de changement et i) est un mouvement qui signifie à l\u0026rsquo;intérieur de la parenthèse (inside parenthesis en anglais).\nLe point sur le mode normal Il s\u0026rsquo;agit là d\u0026rsquo;une parcelle de tout ce que Vim offre. Une fois mémorisées, ces commandes permettent de propulser la modification de texte de manière considérable.\nBien sûr, je ne mène pas un combat idéologique contre la souris. Celle-ci a son utilité, mais ce n\u0026rsquo;est bien sûr pas dans la modification de texte.\nIntégration de l\u0026rsquo;interface système Par exemple, on peut facilement ordonner les lignes d\u0026rsquo;un fichier en faisant simplement\n1  :%!sort  Ici, c\u0026rsquo;est le programme sort de l\u0026rsquo;IS qui est appelé directement avec en entrée toutes les lignes du fichier (% est un intervalle et signifie tout le fichier) et ! signifie un appel à l\u0026rsquo;IS. Définissons un exemple en appelant seq. Pour ce faire, on écrit :r!seq 10:\n1 2 3 4 5 6 7 8 9 10 Ici :r est un diminutif de :read et permet donc de lire un fichier et l\u0026rsquo;écrire après le curseur. Dans ce cas-ci, on lit la sortie standard de la commande seq 10 lancé à l\u0026rsquo;IS. On peut alors mêler les nombres avec shuf en écrivant :%!shuf:\n3 10 7 6 1 8 5 2 4 9 Les nombres sont alors placés dans un ordre aléatoire. On peut ordonner le tout avec sort -n. Encore une fois, on écrit :%!sort -n pour obtenir la liste de départ ordonnée.\nUn autre programme très connu de l\u0026rsquo;IS est grep. Eh bien, on peut aisément l\u0026rsquo;utiliser pour affecter le tampon mémoire courant de la même manière que dans l\u0026rsquo;exemple précédent. Disons qu\u0026rsquo;on ait le tampon mémoire suivant:\nLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. et qu\u0026rsquo;on ne veuille garder que les lignes contenant le sous-mot du, alors on peut simplement écrire %!grep '\\\u0026lt;\\S*du\\S*\\\u0026gt;' pour obtenir:\ntempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, Personnellement, l\u0026rsquo;exemple que je préfère est celui du presse-papier web (ou pastebin). Plusieurs outils en ligne de commande (IS) existent comme pastebinit ou encore dpaste, un programme que j\u0026rsquo;ai moi-même écrit qui fonctionne sur une table de hachage distribuée. Ainsi, afin de partager un fichier sur un presse-papier web, on n\u0026rsquo;a qu\u0026rsquo;à écrire:\n1  :w !dpaste  et on obtient alors le PIN (ou l\u0026rsquo;URL dans le cas de pastebinit) à partager à quelqu\u0026rsquo;un par notre moyen préféré. Ici, :w est un diminutif de :write qui permet d\u0026rsquo;écrire le tampon mémoire dans un fichier. En l\u0026rsquo;occurrence, il s\u0026rsquo;agit de l\u0026rsquo;entrée standard de la commande dpaste. On voudra nécessairement copier le PIN (ou l\u0026rsquo;URL) qui sera retourné par le programme. On peut le faire d\u0026rsquo;un coup en utilisant les tubes de l\u0026rsquo;IS:\n1  :w !dpaste | xsel -b  Ici, xsel est un programme lisant son entrée standard et redirigeant celle-ci vers le presse-papier du système.\nIl est important de comprendre que toutes ces notions sont importées directement depuis l\u0026rsquo;interface système, c.-à-d. qu\u0026rsquo;il est suffisant de connaître l\u0026rsquo;IS afin de tirer avantage de ces fonctionnalités dans Vim. Puissant, n\u0026rsquo;est-ce pas?\nGDB Comme l\u0026rsquo;IS est l\u0026rsquo;EDI d\u0026rsquo;un utilisateur de Vim, il est courant d\u0026rsquo;utiliser directement GDB par l\u0026rsquo;intermédiaire d\u0026rsquo;une seconde fenêtre comme l\u0026rsquo;illustre l\u0026rsquo;image ci-après.\nBien que cela fonctionne convenablement, depuis Vim 8, il est maintenant possible d\u0026rsquo;utiliser GDB directement depuis Vim (voir :help :Termdebug). Voici ce à quoi cela ressemble:\nEn plus de fournir un aperçu en direct du débogage dans le tampon mémoire, différentes commandes sont intégrées afin de communiquer directement avec GDB. À ce sujet, si quelqu\u0026rsquo;un s\u0026rsquo;intéresse à obtenir une configuration de touches effective dès, et seulement, lorsque :Termdebug est lancé, voir ma configuration.\nGreffons GDB c\u0026rsquo;est bien pour le débogage, mais qu\u0026rsquo;en est-il de l\u0026rsquo;assistance à l\u0026rsquo;écriture du code. À cet effet, je propose la découverte de différents greffons que je décris dans le reste de ce billet de blog. En particulier, je survolerai les greffons suivants:\n UltiSnips YouCompletMe Haskell IDE Engine  UltiSnips URL: https://github.com/SirVer/ultisnips\nCe greffon permet de développer des bouts de code prédéfinis (snippet en anglais) dans le tampon mémoire en fonction du type de fichier qu\u0026rsquo;on ouvre. Par exemple, dans un fichier de type cpp, on peut transformer le texte suivant:\n1  main   en le bout de code ci-après:\n1 2 3 4  int main(int argc, char *argv[]) { return 0; }   N.B: Ultisnips ne contient pas de bouts de code par défaut. Il faut donc les écrire soi-même ou utiliser un greffon de bouts de code comme vim-snippets initié par honza. Les bouts de code offerts sur ce dépôt sont nombreux et j\u0026rsquo;invite fortement à utiliser ce greffon en pair avec Ultisnips.\nAnalyseur syntaxique et complétion de mots Un analyseur syntaxique est un composant important d\u0026rsquo;un EDI moderne. En effet, la vitesse à laquelle les analyseurs syntaxiques permettent de communiquer l\u0026rsquo;information sur l\u0026rsquo;exactitude de ce qu\u0026rsquo;écrit le développeur est un facteur important à considérer. De plus, la complétion des mots est un incontournable dans différents langages où il est coutume d\u0026rsquo;écrire de longs mots pour décrire les variables ou fonctions du programme.\nÀ la base, Vim prend en charge un outil s\u0026rsquo;apparentant à la complétion de mots. Il s\u0026rsquo;agit de ctags (voir ctags-universal). Ceci dit, cette solution est limitée puisqu\u0026rsquo;elle n\u0026rsquo;effectue pas une analyse du programme comme tel, mais se contente de simplement relever les mots sans tenir compte de la syntaxe. Ces mots sont ensuite stockés dans un fichier qu\u0026rsquo;on doit par la suite fournir à Vim par l\u0026rsquo;option 'tags'. Par exemple, si on un projet avec une structure comme celui-ci:\n1 2 3 4 5 6 7 8 9  . ├── Makefile ├── README └── src ├── interface.cpp ├── interface.h ├── main.cpp ├── tools.cpp └── tools.h   On peut configurer le tout en appelant ctags:\n1  $ ctags -R src/   Ceci génère le fichier tags. Ainsi, on indique finalement à Vim la présence du fichier en configurant l\u0026rsquo;option appropriée: :set tags=./tags.\nBien que cette approche soit limitée, elle est souvent complémentaire lorsqu\u0026rsquo;on cherche à sauter à la définition d\u0026rsquo;un mot (la définition d\u0026rsquo;une fonction par exemple). Les solutions décrites plus bas permettent normalement déjà cela, mais dans les cas où un certain langage n\u0026rsquo;est pas pris en charge par les différents analyseurs syntaxiques décrits plus bas, l\u0026rsquo;utilisation de ctags-universal peut-être appropriée.\nYouCompletMe (C++, Python, Java, Go, Rust, JavaScript, C#, \u0026hellip;) URL: https://github.com/SirVer/ultisnips\nAux grands problèmes, les grandes solutions!\nOui, ce greffon n\u0026rsquo;est pas léger, mais fait un très bon travail. Il prend en charge de nombreux langages (tout dépend de l\u0026rsquo;analyseur syntaxique configuré selon le langage) et s\u0026rsquo;exécute en tâche de fond sans importuner le développeur (depuis Vim 8). Une fois installé et configuré (voir la documentation, FAQ et le wiki), il suffit d\u0026rsquo;ouvrir un fichier source de votre projet afin de se lancer.\nDans le cas de Python, le tout devrait fonctionner directement. Cependant, pour C++, il est nécessaire de faire une étape supplémentaire afin de faire fonctionner YouCompleteMe avec les bons drapeaux de compilation. Pour ce faire, on doit donc ouvrir Vim dans le répertoire du projet (vérifier que :pwd donne bien la racine de votre projet) et lancer :YcmGenerateConfig. Cette commande détectera l\u0026rsquo;outil de compilation utilisé (Makefile par exemple) et lancera la compilation afin de récupérer les drapeaux. Cette étape générera un fichier nommé .ycm_extra_config.py. Le mieux est de placer ce fichier à la racine de votre projet si celui-ci n\u0026rsquo;y apparaît pas à cet endroit directement, une fois généré.\nIl est aussi pertinent de considérer l\u0026rsquo;utilisation d\u0026rsquo;un fichier ~/.ycm_extra_config.py. Comme ce fichier est placé dans votre répertoire personnel ~, il servira de configuration de base au cas où aucun fichier de configuration n\u0026rsquo;est présent dans votre projet ou si vous modifiez un fichier seul. Faites attention à n\u0026rsquo;y inclure que des drapeaux pertinents pour tout fichier de base sans configuration particulière. On pense notamment à des drapeaux comme -std=c++17.\nHIE / LanguageClient (Haskell) URL: https://github.com/haskell/haskell-ide-engine\nPour les amoureux de Haskell, ce programme est un incontournable. Il rend l\u0026rsquo;écriture beaucoup plus aisée comme c\u0026rsquo;est attendu pour la plupart des langages.\nL\u0026rsquo;utilisateur doit se référer à la page principale du projet afin de trouver toutes les instructions d\u0026rsquo;installation et de configuration.\nRemarque: Afin d\u0026rsquo;installer le tout avec cabal et non pas avec stack comme suggéré sur leur page, il était suffisant de rouler la commande suivante à partir de la racine du dépôt:\n1  $ bash cabal-hie-install hie-8.6.5   Une fois que c\u0026rsquo;est complété, il est obligatoire d\u0026rsquo;ajouter le greffon pour Vim en particulier, il s\u0026rsquo;agit de LanguageClient. Encore une fois, il est nécessaire de suivre les instructions de configurations que je ne liste pas complètement ici.\nAutres greffons Afin d\u0026rsquo;avoir plus d\u0026rsquo;idées de greffons à installer en fonction de vos besoins, je vous suggère de vous référer à ma configuration Vim disponible sur Github. En particulier, vous pouvez consulter la liste de mes greffons ici.\nEn conclusion La particularité première de Vim est sa conception des différents modes d\u0026rsquo;édition (Normal, Insertion, Visuel, etc.). Ces modes ne s\u0026rsquo;arrêtent vraiment pas à la parcelle que j\u0026rsquo;ai exposée dans cet article. Ils sont vastes. Il y a beaucoup à découvrir. Ce faisant, il n\u0026rsquo;est pas si simple de dire qu\u0026rsquo;on pourrait aussi bien utiliser un greffon pour Visual Studio afin d\u0026rsquo;intégrer Vim car dans la majeure partie des cas, il ne s\u0026rsquo;agit que d\u0026rsquo;un sous-ensemble très restreint de fonctionnalités qui sont incluses dans ce genre de greffon. Ainsi, je préfère largement utiliser Vim avec ses greffons que l\u0026rsquo;inverse susmentionné. C\u0026rsquo;est pourquoi j\u0026rsquo;encourage quiconque à prendre le temps de découvrir Vim.\nLa courbe d\u0026rsquo;apprentissage Comme on dit si bien ces temps-ci, tout est dans l\u0026rsquo;aplatissement de la courbe. ;)\nOui, la courbe est à pic (pas autant que le suggère l\u0026rsquo;image :P), mais elle vaut la peine (comme l\u0026rsquo;indique l\u0026rsquo;image cette fois-ci :P). En travaillant petit à petit, on y arrive.\nRéférences additionnelles Je renvois le lecteur vers les référence suivantes afin qu\u0026rsquo;il en apprenne plus sur Vim:\n vimtutor: sur la ligne de commande (après avoir installé Vim sur votre système). VIM(1): la page de manuel pour Vim (encore une fois après avoir installé Vim). Learn Vim the hard way. Un livre web sur VimScript. Cela donne beaucoup d\u0026rsquo;informations pertinentes sur la structure de Vim et de VimScript. Des viédos tutoriel sur Vim sont disponible sur YouTube à profusion. Il n\u0026rsquo;y a qu\u0026rsquo;à chercher un peu. Si vous êtes plus du genre à jouer, Vim Adventures est une très bonne option pour débuter.  ","description":"","id":12,"section":"vim","tags":["Vim","hjkl","greffon"],"title":"Vim peut tout faire","uri":"https://sim590.github.io/fr/vim/vim-peut-tout-faire/"},{"content":"Lorsqu\u0026rsquo;on utilise les différents outils de communications habituels de nos jours, il est commun de supposer la garantie de sa vie privée. L\u0026rsquo;utilisateur moyen ne se pose aucune question lorsqu\u0026rsquo;il se connecte à des services comme Facebook, Twitter ou Skype. Ou encore, on se rassure tout de suite à l\u0026rsquo;idée de voir des symboles de \u0026ldquo;sécurité\u0026rdquo; comme le suivant.\nTous les services susmentionnés sont effectivement munis de protections, mais contre et pour qui? Et sous quelle(s) hypothèse(s)? Il s\u0026rsquo;avère que les mesures de sécurité des logiciels communiquant sur les réseaux ne protègent réellement que les entreprises derrière les services associés. La vie privée des individus n\u0026rsquo;est, en majeure partie des cas, pas préservée d\u0026rsquo;aucune manière.\nAfin de bien comprendre pourquoi, prenons un moment pour définir quelques termes et concepts centraux.\nDéfinitions Selon le standard ISO 27000 (2018), on décrit les termes suivant:\n Confidentialité: « propriété selon laquelle l\u0026rsquo;information n\u0026rsquo;est pas rendue disponible ni divulguée à des personnes, des entités ou des processus non autorisés »; Intégrité: « propriété d\u0026rsquo;exactitude et de complétude »; Authentification: « moyen pour une entité d\u0026rsquo;assurer la légitimité d\u0026rsquo;une caractéristique revendiquée .»  La confidentialité est assurée par ce qu\u0026rsquo;on appelle le chiffrement. Ceci correspond plus précisément à une action rendant inintelligible une information par l\u0026rsquo;exécution d\u0026rsquo;un procédé irréversible, nommé chiffre ou méthode de chiffrement, pour quiconque n\u0026rsquo;ayant pas l\u0026rsquo;information nécessaire. L\u0026rsquo;information en question est appelée clef et permet de déchiffrer une donnée chiffrée, c\u0026rsquo;est-à-dire de rendre cette information intelligible à nouveau.\nOn assure ensuite l\u0026rsquo;authenticité d\u0026rsquo;un émetteur ou récepteur par des signatures numériques. Celles-ci peuvent prendre plusieurs formes, comme des codes d\u0026rsquo;authentification de message (CAM) ou des signature de clef privée.\nSécurité par un tiers Le modèle qu\u0026rsquo;on retrouve le plus souvent est celui d\u0026rsquo;une communication où les procédures de sécurisation des communication s\u0026rsquo;effectuent dans un premier temps entre un client et un serveur. Cette approche est représentée dans l\u0026rsquo;image ci-après.\nOn dépeint ici la communication entre le client A et le client B par l\u0026rsquo;intermédiaire du serveur. On remarque, dans un premier temps, que le chiffrement est dès lors opérationnel entre le client A et le serveur. Ceci est représenté par la possession d\u0026rsquo;une clef K_A par A et le serveur ainsi que la flèche verte. Les deux partis de cette communication peuvent donc échanger de manière sûre par ce canal. Idem pour B et le serveur avec la clef K_B.\nCe modèle est celui de multiples services de communication comme: Facebook, Twitter, Skype, Instagram, service de courriel (Outlook, GMail, etc.), \u0026hellip;\nFaille flagrante de ce modèle Il faut rappeler que le diagramme veut représenter un échange entre A et B. Or, lorsque A envoie un message à B, celui-ci passe par le serveur et est protégé, c\u0026rsquo;est-à-dire qu\u0026rsquo;il est chiffré, jusqu\u0026rsquo;à ce qu\u0026rsquo;il atteigne le serveur. Une fois rendu, le message est déchiffré. Du point de vue de A et de B, il n\u0026rsquo;y a aucun moyen de savoir ce qui se passe sur le serveur avec les messages qui sont transmis au serveur entre le moment où le serveur les reçoit et le moment où il les relaye à son destinataire. En effet, le serveur peut très bien stocker ces messages, les analyser, les propager avec un autre parti, les vendre, etc.\nCe faisant, la sécurité de ce modèle fait une supposition très grave: vous devez être en parfaite confiance avec le fournisseur du service pour que celui-ci ne touche pas à vos données. Dans un monde où les données récoltées de manière massive représentent un capital considérable, il est clair que cette hypothèse devient de plus en plus difficile à faire tenir.\nPourquoi est-ce important? Nombreuses situations suggèrent le caractère sensible de communications comme c\u0026rsquo;est le cas pour certains individus dont la profession demande de garantir la vie privée de soi ou d\u0026rsquo;autrui. On peut penser à des journalistes qui doivent assurer la confidentialité de leur communication, un psychologue qui ne doit pas divulguer d\u0026rsquo;information sur son patient, une personne nécessitant une protection contre les démarches abusives d\u0026rsquo;un état ou un simple civil dont les droits peuvent être abusés au bon moment suite à l\u0026rsquo;accumulation de données sur sa personne.\nIl est facile de s\u0026rsquo;imaginer le danger que cela peut représenter pour une population victime du totalitarisme de leur État. Cependant, il n\u0026rsquo;est pas obligatoire d\u0026rsquo;être citoyen d\u0026rsquo;un tel État pour s\u0026rsquo;inquiéter. La menace que constitue l\u0026rsquo;accumulation de données sur des individus est bien réel et ce n\u0026rsquo;est pas un hasard si la vie privée est reconnue formellement comme un droit depuis 1947 par la commission des droits de la personne.\nIl est trop facile de se laisser prendre et de considérer que cette faille n\u0026rsquo;est pas assez majeure. Je ne peux pas insister assez sur le fait qu\u0026rsquo;il n’ya aucun moyen de connaître le véritable traitement réservé à nos données dans un tel modèle et que la seule manière d\u0026rsquo;éviter ce problème est d\u0026rsquo;opter pour une formule différente qui respecte vraiment la vie privée de ses usagers, peu importe ce qu\u0026rsquo;en disent les \u0026ldquo;politiques\u0026rdquo; d\u0026rsquo;utilisation des données affichées par les fournisseurs de service.\nLeur parole n\u0026rsquo;est rien comparativement à l\u0026rsquo;assurance que promet le chiffrement de bout en bout.\nChiffrement de bout en bout Quand on dit «sécurité», on entend l’aptitude d\u0026rsquo;un système à préserver diverses propriétés dont nécessairement la confidentialité, l\u0026rsquo;intégrité et l\u0026rsquo;authentification. Lorsque le système est capable de garantir les propriétés désirées, on dit qu\u0026rsquo;il est sûr. La sûreté de bout en bout est l\u0026rsquo;exigence que les propriétés de sécurité du système soient préservées pour tous ses participants sans l\u0026rsquo;existence d\u0026rsquo;un tiers parti faisant exception et pouvant briser une (ou l\u0026rsquo;ensemble) des propriétés. Autrement dit, un système sûr de bout en bout est un système atteignant toutes les propriétés ci-haut alors que toute entité différente des interlocuteurs d\u0026rsquo;une conversation est envisagée comme des ennemis dans le modèle d\u0026rsquo;adversaire.\nLa figure ci-haut illustre ce phénomène. De façon similaire à la figure précédente, la communication est sécurisée entre A et B, mais le serveur n\u0026rsquo;a aucune connaissance des clefs de chiffrement sur le canal de communication. Ainsi, il peut relayer les données, alors que A et B sont tous deux certains que le serveur (comme tout autre tiers) n\u0026rsquo;a aucune façon d\u0026rsquo;apprendre le contenu des communications entre eux.\nCette formule se prête à un grand nombre d\u0026rsquo;applications, mais nous nous limitons au cas du clavardage afin de fournir des exemples concrets. L\u0026rsquo;exemple par excellence mettant en œuvre ce modèle est Signal.\nSignal «L\u0026rsquo;axolotl, Ambystoma mexicanum, est une espèce de salamandre néoténique faisant partie de l\u0026rsquo;ordre des urodèles et de la famille des Ambystomatidae [\u0026hellip;] Une particularité de cet animal est sa capacité à régénérer des organes endommagés ou détruits.» (Wikipedia)\nCe n\u0026rsquo;est pas un hasard si Signal (son protocole du moins) a eu comme premier nom «Axolotl». Moxie Marlinspike, le créateur de Signal, avait très bien résumé la capacité de son modèle à garantir une autorégénération de la confidentialité de ses utilisateurs au fil du temps d\u0026rsquo;une discussion. La particularité première de Signal est qu\u0026rsquo;il permet de rétablir la confidentialité d\u0026rsquo;une conversation entre deux personnes suivant la fuite d\u0026rsquo;information éventuelle. Ce faisant, comme l\u0026rsquo;axolotl, Signal se guérit à mesure qu\u0026rsquo;il subit des fuites et il le fait avec efficacité dans un contexte asynchrone. C\u0026rsquo;est la raison principale qui fait du protocole de communication de Signal l\u0026rsquo;exemple de ce qui se fait de mieux en matière de communication sûre de bout en bout.\nPour une description détaillée du protocole, référez-vous à mon mémoire (pages 78-82).\nDe mon point de vue, Signal est la meilleure recommandation que je puis faire pour quiconque souhaitant un haut niveau de vie privée. Une caractéristique importante en ce qui a trait à la sécurité est qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un logiciel libre (voir la mise en garde contre les logiciels propriétaires à la fin de cet article).\nPoints faibles Malgré son excellence, Signal souffre tout de même de points faibles non négligeables.\nCouplage avec le téléphone\nEn effet, Signal ne peut fonctionner sans un téléphone intelligent. Bien que l\u0026rsquo;application de bureau Signal existe, il est obligatoire de la lier à une instance installée sur son téléphone mobile. Cela rend donc difficile l\u0026rsquo;utilisation de Signal par certains ne possédant pas téléphone. De plus, comme les appareils mobiles utilisant Android ou iOS ne sont pas formellement sûrs par leur nature propriétaire et puisqu\u0026rsquo;ils ne sont pas conçus en soi pour préserver la vie privée des usagers, il est nécessaire de garantir la sécurité de son appareil mobile afin de jouir des pleines capacités de Signal.\nCommunication de groupe moins sûre que la communication en pair à pair\nEn effet, le protocole de communication n\u0026rsquo;est pas le même lorsque plus d\u0026rsquo;un pair souhaite échanger dans une même conversation sur Signal. Ce faisant, il faut prendre ça en considération si notre priorité est de minimiser les fuites.\nAutres possibilités D\u0026rsquo;autres applications permettent de tirer un haut niveau de sécurité. Certaines ont une étendue d’usages plus variée ou un objectif principal différent, mais servent tout de même la fonction de clavardage.\n  Matrix. Il s\u0026rsquo;agit d\u0026rsquo;un réseau décentralisé plutôt qu\u0026rsquo;une application. Il y a différents moyens de s\u0026rsquo;y connecter comme par Riot. La liste complète des applications compatibles peut se trouver à l\u0026rsquo;adresse suivante:\nhttps://matrix.org/docs/projects/try-matrix-now\nLa documentation pour le protocole pair à pair peut se trouver ici et pour le protocole de groupe, ici. Il s\u0026rsquo;agit d\u0026rsquo;une implémentation des idées de Signal, alors le niveau de sécurité est très semblable s\u0026rsquo;il n\u0026rsquo;est pas identique.\n  WhatsApp et les conversations secrètes de Facebook sont des possibilités. Le lecteur est cependant averti de bien lire la mise en garde ci-après à ce sujet. En particulier, l\u0026rsquo;option de Facebook n\u0026rsquo;est pas optimale dans sa présentation visuelle, ce qui le rend encore moins intéressant.\n  Mise en garde Lorsqu\u0026rsquo;il vient le temps de parler sécurité et de confidentialité, l\u0026rsquo;utilisation de logiciel propriétaire engendre un énorme déclin de confiance sur l\u0026rsquo;effectivité de la garantie de confidentialité. En effet, on ne peut assurer que le logiciel n\u0026rsquo;est pas truffé de code-espion. Bien que le garantir pour une application libre n\u0026rsquo;est toujours pas chose triviale, c\u0026rsquo;est toutefois possible. En résumé, il vaut bien mieux opter pour une solution libre si la confidentialité est le souci principal.\n","description":"","id":13,"section":"cybersécurité","tags":["Chiffrement","Chiffrement de bout en bout","Confidentialité","Signal","WhatsApp","Protocole","Protocole de communication","Communication"],"title":"Comment bien assurer la vie privée du clavardage?","uri":"https://sim590.github.io/fr/cybers%C3%A9curit%C3%A9/comment-bien-assurer-la-confidentialit%C3%A9-du-clavardage/"},{"content":" L\u0026rsquo;approche de programmation dynamique est souvent associée au remplissage d\u0026rsquo;un tableau à deux dimensions et à l\u0026rsquo;écriture explicite de ce procédé sous forme itérative. Dans un langage fonctionnel comme Haskell, on bénéficie de quelques avantages d\u0026rsquo;expressivité de haut niveau et de lisibilité qu\u0026rsquo;on ne retrouve pas autrement.\nDans cet article, je commence par explorer deux exemples triviaux de programmation dynamique. Ensuite, je passe sur un problème tout aussi accessible, mais dont l\u0026rsquo;achèvement optimal demandera l\u0026rsquo;utilisation d\u0026rsquo;une structure Data.Array plutôt que la liste conventionnelle.\nÉvaluation paresseuse La particularité principale d\u0026rsquo;Haskell est qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un langage paresseux, c\u0026rsquo;est-à-dire que l\u0026rsquo;évaluation d\u0026rsquo;une expression ou d\u0026rsquo;une valeur est faite de manière paresseuse. Plus précisément, on peut formuler ce concept par la propriété d\u0026rsquo;un langage à garantir l\u0026rsquo;évaluation de la valeur d\u0026rsquo;une expression donnée que si celle-ci est bien nécessaire à un calcul subséquent. Par exemple, considérons l\u0026rsquo;expression repeat 0. Cette expression correspond à une liste de taille virtuellement infinie. Cependant, head (repeat 0) correspond à une valeur de taille finie, en l\u0026rsquo;occurence 0. Comme Haskell est paresseux, il ne tente d\u0026rsquo;évaluer repeat 0 « complètement » que si c\u0026rsquo;est ce qui lui est demandé. Or, en passant repeat 0 en argument à head, on indique à Haskell qu\u0026rsquo;on n\u0026rsquo;est intéressé que par le premier élément, alors la liste repeat 0 ne sera jamais générée au complet, mais seul le premier élément sera calculé.\nDiviser pour régner et calculs en double Lorsqu\u0026rsquo;on souhaite résoudre un problème complexe, il est commun d\u0026rsquo;employer une approche où on réduit un problème à des sous-problèmes permettant ainsi de converger éventuellement en une solution finale. Cette approche s\u0026rsquo;appelle « diviser pour régner » et permet l\u0026rsquo;écriture de solutions élégantes (voir l\u0026rsquo;algorithme de tri fusion).\nL\u0026rsquo;indicateur premier de la pertinence d\u0026rsquo;investiguer pour une approche de programmation dynamique est celui de l\u0026rsquo;occurrence de calculs faits en double. Comme la méthode « diviser pour régner », l\u0026rsquo;approche de programmation dynamique se base sur un principe de division d\u0026rsquo;un problème en sous-problèmes suivant le principe d\u0026rsquo;optimalité de Bellman:\n Une solution optimale à un problème s\u0026rsquo;obtient en combinant des solutions optimales à des sous-problèmes.\n En d\u0026rsquo;autres termes, pour que le principe s\u0026rsquo;applique, il est nécessaire que la combinaison des solutions aux sous-problèmes soit optimale, lorsque les solutions aux sous-problèmes sont elles-mêmes optimales.\nSuite de Fibonacci 1  import Numeric.Natural   Considérons le problème de déterminer le \\(n^{\\text{ème}}\\) terme de la suite de Fibonacci. La récurrence très connue, définie sur les entiers naturels, est la suivante:\n$$ f(n) = \\begin{cases} 0 \u0026amp; \\text{si}\\ n=0\\\\\n1 \u0026amp; \\text{si}\\ n=1\\\\\nf(n-1) + f(n-2) \u0026amp; \\text{sinon} \\end{cases} $$\nL\u0026rsquo;écriture de cette fonction, suivant cette relation, est évidente:\n1 2 3 4  fib :: Natural -\u0026gt; Natural fib 0 = 0 fib 1 = 1 fib n = fib (n-1) + fib (n-2)   Cet algorithme est cependant non optimal puisqu\u0026rsquo;il est facile de voir que celui-ci effectue plusieurs calculs en double. Par exemple, pour \\(f(5)\\) on doit calculer \\(f(3)\\) et \\(f(4) = f(2) + f(3)\\). On voit bien qu\u0026rsquo;au moment de calculer \\(f(4)\\), il serait pertinent de récupérer la valeur déjà calculée \\(f(3)\\) afin d\u0026rsquo;éviter de la recalculer. Malheureusement, l\u0026rsquo;algorithme décrit plus haut ne fait pas cela. Il vaut la peine de noter que plus la valeur de \\(n\\) est élevée, plus le nombre de redondance augmente, ce qui gonfle ainsi la gravité du problème.\nFibonacci: optimisation La programmation dynamique nous permet de régler ce problème. Par exemple, on pourrait écrire la chose suivante:\n1 2 3 4 5  mfib :: Int -\u0026gt; Natural mfib = (map fib [0..] !!) -- (ii) where fib 0 = 0 fib 1 = 1 fib n = mfib (n-2) + mfib (n-1) -- (i)   Le changement apporté au code plus haut devrait être analysé en plusieurs parties. Premièrement, on retrouve la définition de fib qui ressemble pas mal à la première écriture. Cependant, on remarque que la définition du cas général \\((i)\\) ne fait plus directement appel à fib, mais à mfib. Deuxièmement, on remarque que la définition principale de mfib \\((ii)\\) fait un appel à fib. On a donc deux fonctions s\u0026rsquo;appellant en chaîne, ce qui ferme la boucle d\u0026rsquo;appels:\n$$\\texttt{fib} \\rightarrow \\texttt{mfib} \\rightarrow \\texttt{fib} \\rightarrow \\dots$$\nAinsi, le tout correspond à une fonction récurisve convergeant vers les cas de base tout comme c\u0026rsquo;était le cas dans la première approche. Ceci dit, l\u0026rsquo;entrelacement entre mfib et fib forme justement la différence majeur entre les deux approches. En effet, mfib est défini comme l\u0026rsquo;accès (!!) au \\(n^{\\text{ème}}\\) élément de la liste\n1  map fib [0..] -- (ii)   Cette liste correspond bien sûr à la liste abstraite suivante:\n[fib 0, fib 1, fib 2, ...] \nNotons premièrement que la liste map fib [0..] est une expression correspondant à une liste infinie. Mais comme Haskell est un langage paresseux, seuls les éléments nécessaires au calcul demandé par l\u0026rsquo;appel initial de mfib seront calculés.\nRegardons de plus près ce qui se passe avec un exemple sur mfib 5. Premièrement, l\u0026rsquo;accès au \\(5^\\text{ème}\\) élément de la liste sera demandé, ce qui engendrera l\u0026rsquo;appel à fib 5 qui en retour correspond à mfib 3 et mfib 4. L\u0026rsquo;expression partielle correspondant au calcul demandé initialement est donc mfib 3 + mfib 4. Or, mfib 3 est le \\(3^\\text{ème}\\) élément de la liste \\((ii)\\). On déduit une chose similaire pour mfib 4.\nOn pourrait croire un instant qu\u0026rsquo;Haskell pourrait calculer mfib 3 une fois, le stocker dans le tableau et que, le moment venu, mfib 4 provoque le même calcul, mais il s\u0026rsquo;avère qu\u0026rsquo;Haskell partage la liste \\((ii)\\) entre les différents appels de fib. Ainsi, le premier fil d\u0026rsquo;exécution permettant de calculer fib 3 provoquera l\u0026rsquo;inscription de cette valeur dans la liste afin que les appels subséquents n\u0026rsquo;aient qu\u0026rsquo;à réutiliser la valeur dans la liste. Il s\u0026rsquo;agit là de la forme la plus évidente et intuitive de l\u0026rsquo;écriture de cet algorithme sous une approche de programmation dynamique. Autrement, il est possible aussi d\u0026rsquo;écrire une expression remplissant la même fonction en une ligne:\n1 2  fibs :: [Natural] fibs = 0 : 1 : zipWith (+) fibs (tail fibs)   Cett expression correspond bien sûr à la liste de tous les nombres de Fibonacci. Il suffit maintenant d\u0026rsquo;accéder à l\u0026rsquo;élément qu\u0026rsquo;on souhaite, par exemple le \\(5^\\text{ème}\\), avec fibs !! 5. Ici encore, on emploie une approche de programmation dynamique puisque la liste est progressivement construite en réutilisant les deux derniers éléments de la liste pour les additionner afin de former le prochain élément ad infinitum.\nNombres triangulaires 1  import Numeric.Natural   Considérons maintenant le problème de générer les nombres triangulaires. On sait que \\(t_n\\), le \\(n^{\\text{ème}}\\) nombre triangulaire, est donné par l\u0026rsquo;expression suivante:\n$$ t_n = \\sum_{i=1}^n i = 1 + 2 + \\dots + n$$\nUne première approche vient rapidement en tête:\n1 2  triangs :: [Natural] triangs = [sum [1..n] | n \u0026lt;- [1..]]   Cependant, cette première approche est absolument affreuse. On refait clairement plusieurs fois les mêmes calculs. On pourrait aussi tirer avantage du fait que \\(t_n\\) trouve l\u0026rsquo;expression équivalente suivante:\n$$ t_n = \\frac{n(n+1)}{2} $$\nAinsi, on pourrait alors écrire:\n1 2  triangs\u0026#39; :: [Natural] triangs\u0026#39; = [n * (n + 1) `div` 2 | n \u0026lt;- [1..]]   Bien que cette stratégie, reposant sur un astuce analytique, apporterait là une amélioration substantielle, cela ne ferait pas de cette approche une voie tout à fait optimale. En effet, on remarque qu\u0026rsquo;on effectue une multiplication, une division et une addition pour chaque élément généré. Il est possible de faire mieux en utilisant la programmation dynamique. De façon similaire à la dernière solution pour Fibonacci, on peut écrire:\n1 2  triangs\u0026#39;\u0026#39; :: [Natural] triangs\u0026#39;\u0026#39; = 1 : zipWith (+) triangs\u0026#39;\u0026#39; [2..]   Ici, on créé encore une fois une liste qui se joint à une seconde liste, la liste infinie [2..], par l\u0026rsquo;addition des éléments de chaque liste deux à deux. On peut développer l\u0026rsquo;expression comme suit:\n1 2 3  1 : zipWith (+) [1,...] [2,3,4...] correspond à [1, 3, ...] 1 : 3 : zipWith (+) [3,...] [3,4,5...] correspond à [1, 3, 6, ...] 1 : 3 : 6 : zipWith (+) [6,...] [4,5,6...] correspond à [1, 3, 6, 10, ...]   Évidemment, une méthode plus intuitive (mais plus verbeuse) est aussi possible.\nSéquences de Collatz 1 2  import Numeric.Natural import Data.Array   Bien que ce prochain problème n\u0026rsquo;est pas d\u0026rsquo;un ordre différent de difficulté, nous allons prendre une avenue qui diffère légèrement afin de garantir encore un rendement optimal.\nUne séquence de Collatz est une séquence de nombres générée suivant un nombre en entrée, appelons cet élément « racine ». Soit \\(g: \\mathbb{N} \\longrightarrow \\mathbb{N}\\) définie comme:\n$$ g(m) = \\begin{cases} \\frac{m}{2} \u0026amp; \\text{si}\\ m\\ \\text{est pair}\\\\\n\\\\ % Nécessaire car autrement, l\u0026rsquo;équation n\u0026rsquo;arrive pas à se dessiner (trop serré) 3m + 1 \u0026amp; \\text{sinon} \\end{cases} $$\nUne séquence de Collatz, pour une racine \\(r\\), est définie comme la suite\n$$(g(r), (g \\circ g)(r), (g \\circ g \\circ g)(r), \\dots, 1).$$\noù \\(\\circ\\) représente la composition de fonction.\nProblème Pour \\(n \\in \\mathbb{N}\\), on souhaite déterminer la taille de la plus longue séquence de Collatz pour tout \\(1 \\le r \\le n\\).\nUne approche naïve pourrait ressembler à la suivante. Définissons premièrement une fonction calculant la prochaine valeur de la séquence. Appelons la step:\n1 2 3 4 5  step :: Natural -\u0026gt; Natural step 1 = 1 step m | even m = m `div` 2 | otherwise = (3 * m + 1) `div` 2   Remarquons que le cas où \\(m\\) est impair n\u0026rsquo;est plus \\(3m+1\\), mais maintenant \\(\\frac{(3m+1)}{2}\\). Ceci est possible sans perte de généralité puisque si \\(m\\) est impair, alors \\(m=2k+1\\) pour \\(k\\in\\mathbb{N}\\). Ainsi,\n$$ 3m+1 = 3(2k+1)+1 = 2(3k +2) \\quad \\text{est pair}. $$\nCe faisant, le traitement où l\u0026rsquo;argument de step est pair peut tout de suite s\u0026rsquo;appliquer sur l\u0026rsquo;image de \\(3m+1\\). On sauve ainsi une étape à chaque nombre impair rencontré.\nEnsuite, l\u0026rsquo;algorithme bête pour déterminer la longueur d\u0026rsquo;une séquence de Collatz avec pour racine m pourrait ressembler au suivant.\n1 2  dumbSeq :: Natural -\u0026gt; Int dumbSeq m = (+1) $ length $ takeWhile (/=1) $ iterate step m   La lecture est assez directe. On itère sur les appels successifs de step avec comme premier argument m jusqu\u0026rsquo;à ce qu\u0026rsquo;on tombe sur 1. Ici, iterate créé la liste de tous les résultats d\u0026rsquo;applicaiton de step. On n\u0026rsquo;a donc qu\u0026rsquo;à prendre la taille de cette liste et additionner 1 (pour compter le nombre 1). Afin de calculer la valeur maximale pour \\(1 \\le r \\le \\text{n}\\), on peut alors calculer comme suit:\n1 2 3  maxDumb :: Natural -\u0026gt; Natural maxDumb 1 = 0 maxDumb n = snd $ maximum $ map (\\ m -\u0026gt; (dumbSeq m, m)) [1..n]   Ici, on créé une liste de paires ordonnées \\((g^i(m), m)\\). On trouve le maximum de cette liste en comparant le premier élément de chaque paire ordonnée (le comportement par défaut de compare tel que défini pour l\u0026rsquo;instance (,) a de la classe Ord).\nClairement, pour \\(n\\) suffisamment grand, le problème peut devenir couteux en temps. On remarque bien sûr que certaines séquences se croisent. Par exemple:\n1 2  r = 3 =\u0026gt; g(3) = g(5) = g(8) = g(4) = g(2) = 1 r = 4 =\u0026gt; g(4) = g(2) = 1   Ce faisant, si on avait à calculer la longueur de la séquence pour \\(g(3)\\) avant \\(g(4)\\), alors le calcul à l\u0026rsquo;itération \\(r=4\\) serait gratuit si nous employions une approche de programmation dynamique.\nSupposons qu\u0026rsquo;on soit intéressé à trouver la réponse pour \\(n\\) très grand. Il serait d\u0026rsquo;abord nécessaire de fixer une taille maximale pour l\u0026rsquo;antémémoire utilisée pour stocker les valeurs déjà calculées. Disons que \\(10^6\\) est raisonnable:\n1 2  bigN :: Natural bigN = 10 ^ (6 :: Natural)   Ensuite, nous définissons la structure seqArray servant d\u0026rsquo;antémémoire ainsi que la routine de comptage des itérations seq' à travers step:\n1 2 3 4 5 6 7 8 9 10  seq\u0026#39; :: Natural -\u0026gt; Natural seq\u0026#39; 1 = 1 seq\u0026#39; i = 1 + next where i\u0026#39; = step i next | i\u0026#39; \u0026gt; bigN = seq\u0026#39; i\u0026#39; | otherwise = seqArray ! i\u0026#39; seqArray :: Array Natural Natural seqArray = listArray bounds\u0026#39; [ seq\u0026#39; i | i \u0026lt;- range bounds\u0026#39;] where bounds\u0026#39; = (1, bigN)   Nous avons grandement avantage ici à utiliser un tableau permettant un accès \\(\\mathcal{O}(1)\\) pour chaque valeur. Bien que c\u0026rsquo;était autant le cas pour les deux problèmes précédents, nous n\u0026rsquo;avons pas introduit l\u0026rsquo;utilisation de Data.Array jusqu\u0026rsquo;ici afin de simplifier les choses.\nFonctionnement Comme précédemment, remarquons la liaison entre seq' et seqArray. On voit bien que seq' est défini en fonction de seqArray et vice versa. D\u0026rsquo;un côté, on peut le voir comme le fait que seq' utilise les valeurs inscrites dans le tableau afin de faire ses calculs. De l\u0026rsquo;autre côté, on peut interpréter que seqArray n\u0026rsquo;est défini que pour les valeurs que seq' prend. Il y a là une différence majeur avec l\u0026rsquo;écriture dans un langage impératif comme ceux s\u0026rsquo;apparentant au langage C, par exemple.\nIl n\u0026rsquo;y a aucune exigence à l\u0026rsquo;endroit du programmeur à déterminer les indices admissibles pour indexation dans le tableau. La paresse d\u0026rsquo;Haskell s\u0026rsquo;occupe de tout.\nSéquence de taille maximale Finalement, la fonction suivante évalue la taille maximale d\u0026rsquo;une séquence pour une racine \\(1 \\le r \\le \\texttt{n}\\).\n1 2 3 4  maxSeq :: Natural -\u0026gt; Natural maxSeq 1 = 0 maxSeq n = l where (_, l) = maximum $ map swap $ genericTake n $ assocs seqArray   ","description":"","id":14,"section":"haskell","tags":["Séquence de Collatz","Data.Array","nombre triangulaire"],"title":"Haskell: programmation dynamique","uri":"https://sim590.github.io/fr/haskell/programmation-dynamique/"},{"content":"Je m\u0026rsquo;appelle Simon Désaulniers. Je suis une personne qui œuvre dans mon quotidien en mathématiques et informatique. Je m\u0026rsquo;intéresse à plusieurs sujets comme:\n l\u0026rsquo;algorithmique; les langages informatiques; la sécurité informatique et la cryptographie; les logiciels et outils informatiques; les systèmes distribués; le logiciel libre et respectueux de la vie privée; l\u0026rsquo;algèbre; etc.  Mes intérêts dépassent bien sûr l\u0026rsquo;informatique et les mathématiques. J\u0026rsquo;aime particulièrement les langues, la culture, la musique, la politique et les jeux vidéo.\nLe contenu de mon site Sur ce site, j\u0026rsquo;expose différents concepts, notions ou pratiques sur différents sujets. J\u0026rsquo;aime partager mes découvertes, résolutions de problème et analyses. J\u0026rsquo;espère ainsi permettre à plusieurs d\u0026rsquo;y tirer quelque chose d\u0026rsquo;utile ou du moins intéressant. Je suis un utilisateur de logiciels libres et en particulier de GNU/Linux depuis 2012. Il se peut donc que des sujets en lien avec cela soient exploités.\n","description":"","id":15,"section":"","tags":null,"title":"À propos de moi","uri":"https://sim590.github.io/fr/a-propos/"},{"content":"  GSOC Comme j\u0026rsquo;ai mentionné dans au article antérieur, je participe au programme Google Summer Of Code grâce à l\u0026rsquo;organisation Debian qui supervise mes travaux contribuant au logiciel libre Ring.\nDeux jours restants Il reste deux jours avant mon départ pour le Cape, en Afrique du sud. C\u0026rsquo;est pour assister à l\u0026rsquo;événement debconf (« Debian conference »), organisé par Debian, que je me rends là. Cet événement est organisé à chaque année et, l\u0026rsquo;année prochaine, c\u0026rsquo;est à Montréal que ça aura lieu !  J\u0026rsquo;ai très hâte de vivre cette expérience qui sera sans doute innoubliable. Debian est une organisation pionière du monde du logiciel libre. Je rencontrerai des gens très dévoués et partageant avec moi beaucoup d\u0026rsquo;intérêts pour le logiciel libre et sa philosophie.\nL\u0026rsquo;Afrique du sud Ce sera la première fois que je prendrai l\u0026rsquo;avion et je ferai une escale à Amsterdam, une ville que j\u0026rsquo;aimerais bien visiter un jour. Ahhhh Jacques Brel.\nJe suis très heureux que le continent d\u0026rsquo;Afrique soit la première destination me permettant de sortir du continent d\u0026rsquo;Amérique pour la première fois. J\u0026rsquo;ai bien hâte de vivre l\u0026rsquo;ambiance du Cape.\nLes requins Y parrait qu\u0026rsquo;y\u0026rsquo;a des requins au Cape.\n","description":"Je m'envole pour le Cape.","id":18,"section":"","tags":null,"title":"Adieu","uri":"https://sim590.github.io/fr/adieu/"},{"content":"Par courriel (sim.desaulniers@gmail.com) ou via LinkedIn.\nL\u0026rsquo;empreinte de ma clef PGP:\n70B9 F71B 74C9 553D 01A1 A0EF 824A 8B97 F97E 4B08  Sinon, vous pouvez simplement utiliser le formulaire suivant:\n","description":"Informations pour me contacter","id":19,"section":"","tags":null,"title":"Contactez-moi","uri":"https://sim590.github.io/fr/contactez-moi/"}]